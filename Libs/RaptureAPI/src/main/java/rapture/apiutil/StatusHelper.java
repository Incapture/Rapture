/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2011-2016 Incapture Technologies LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package rapture.apiutil;

import java.util.Map;

import rapture.common.CallingContext;
import rapture.common.api.RunnerApi;
import rapture.config.MultiValueConfigLoader;

/**
 * Use the LOCAL config file, generated by RaptureRunner to report status via a
 * number of different mechanisms
 * 
 * @author amkimian
 * 
 */
public class StatusHelper {
    public static void setStatusAndCapability(CallingContext context, String status, Map<String, Object> capabilities, RunnerApi runnerApi) {
        String name = MultiValueConfigLoader.getConfig("LOCAL-name");
        String group = MultiValueConfigLoader.getConfig("LOCAL-group");
        String appName = MultiValueConfigLoader.getConfig("LOCAL-appName");
        String server = MultiValueConfigLoader.getConfig("LOCAL-server");
        if (name == null || group == null || appName == null || server == null) {
            return;
        }
        runnerApi.recordRunnerStatus(context, server, group, name, appName, status);
        if (capabilities != null && capabilities.keySet().size() > 0) {
            runnerApi.recordInstanceCapabilities(context, server, name, capabilities);
        }
    }

    private static Thread statusThread;
    private static boolean cont = true;

    public static void startStatusUpdating(final CallingContext context, final RunnerApi api) {
        statusThread = new Thread(new Runnable() {

            @Override
            public void run() {
                while (cont) {
                    setStatusAndCapability(context, "RUNNING", null, api);
                    try {
                        Thread.sleep(10000);
                    } catch (InterruptedException e) {
                    }
                }
            }
        });
        statusThread.setDaemon(true);
        statusThread.setName("StatusUpdater");
        cont = true;
        statusThread.start();
    }

    public static void stopStatusUpdating() {
        if (statusThread != null) {
            cont = false;
        }
    }

}
