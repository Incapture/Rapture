/**
 * Copyright (C) 2011-2015 Incapture Technologies LLC
 *
 * This is an autogenerated license statement. When copyright notices appear below
 * this one that copyright supercedes this statement.
 *
 * Unless required by applicable law or agreed to in writing, software is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * Unless explicit permission obtained in writing this software cannot be distributed.
 */
package rapture.repo.mongodb;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

import rapture.common.CallingContext;
import rapture.kernel.ContextFactory;
import rapture.kernel.Kernel;

public class MongoDbArchiveTest {

    private static CallingContext context = ContextFactory.getKernelUser();

    private static final int TOTAL_VERSIONS = 5;
    private static final int VERSION_LIMIT = 2;

    public void testModel() {
        String repo = "model.FXDM";

        if(!Kernel.getDoc().docRepoExists(context, repo)) {
            Kernel.getDoc().createDocRepo(context, repo, "NREP {} USING MONGODB { prefix=\"model.FXDM.doc\"");
        }

        Kernel.getDoc().archiveRepoDocs(context, repo, VERSION_LIMIT, System.currentTimeMillis(), true);
    }

    @Test
    public void testArchiveVersionedRepo() {
        String repo = "deletelater.vrep_111";
        String path = "//" + repo + "/dir1/doc1";

        // create repo and add content
        createRepo("VREP", repo);
        addContent(path, TOTAL_VERSIONS);

        Kernel.getDoc().archiveRepoDocs(context, path, VERSION_LIMIT, System.currentTimeMillis(), true);

        // check latest version
        assertEquals(getContentForVersion(TOTAL_VERSIONS), Kernel.getDoc().getDoc(context, path));

        deleteRepo(repo);
    }

    @Test
    public void testArchiveNVersionedRepo() {
        String repo = "deletelater.nrep_222";
        int total = 3;

        // create repo and add content
        createRepo("NREP", repo);
        for(int i = 0; i < total; i++) {
            String path = String.format("//%s/dir%d/doc%d", repo, i, i);
            addContent(path, TOTAL_VERSIONS);
        }

        // archive old versions
        Kernel.getDoc().archiveRepoDocs(context, repo, VERSION_LIMIT, System.currentTimeMillis(), true);

        for(int i = 0; i < total; i++) {
            String path = String.format("//%s/dir%d/doc%d", repo, i, i);

            // check latest version
            assertEquals(getContentForVersion(TOTAL_VERSIONS), Kernel.getDoc().getDoc(context, path));

            // old versions should be deleted
            for(int j = 1; j <= TOTAL_VERSIONS - VERSION_LIMIT; j++) {
                assertNull(Kernel.getDoc().getDoc(context, path + "@" + j));
            }

            // recent versions should be intact
            for(int j = TOTAL_VERSIONS - VERSION_LIMIT + 1; j <= TOTAL_VERSIONS; j++) {
                assertEquals(getContentForVersion(j), Kernel.getDoc().getDoc(context, path + "@" + j));
            }
        }

        deleteRepo(repo);
    }

    @Test
    public void testArchiveNVersionedDoc() {
        String repo = "deletelater.nrep_333";
        String path = "//" + repo + "/dir1/doc1";

        // create repo and add content
        createRepo("NREP", repo);
        addContent(path, TOTAL_VERSIONS);

        // archive old versions
        Kernel.getDoc().archiveRepoDocs(context, path, VERSION_LIMIT, System.currentTimeMillis(), true);

        // check latest version
        assertEquals(getContentForVersion(TOTAL_VERSIONS), Kernel.getDoc().getDoc(context, path));

        // old versions should be deleted
        for(int i = 1; i <= TOTAL_VERSIONS - VERSION_LIMIT; i++) {
            assertNull(Kernel.getDoc().getDoc(context, path + "@" + i));
        }

        // recent versions should be intact
        for(int i = TOTAL_VERSIONS - VERSION_LIMIT + 1; i <= TOTAL_VERSIONS; i++) {
            assertEquals(getContentForVersion(i), Kernel.getDoc().getDoc(context, path + "@" + i));
        }

        deleteRepo(repo);
    }

    private void createRepo(String repoType, String repoName) {
        String config = repoType + " {} USING MONGODB { prefix=\"" + repoName + "\" }";
        logFormat("-----Create repo %s %s ----", repoName, config);
        Kernel.getDoc().createDocRepo(context, repoName, config);
    }

    private void deleteRepo(String repoName) {
        logFormat("----- Delete repo %s ----", repoName);
        Kernel.getDoc().deleteDocRepo(context, repoName);
    }


    private void addContent(String path, int versions) {
        for(int i = 1; i <= versions; i++) {
            Kernel.getDoc().putDoc(context, path, getContentForVersion(i));
        }
    }

    private String getContentForVersion(int version) {
        return String.format("{\"key %s\" : \"value %s\"}", version, version);
    }

    @SuppressWarnings("unused")
    private void log(String msg) {
        System.out.println(msg);
    }

    private void logFormat(String format, Object... args) {
        System.out.println(String.format(format, args));
    }

}