/**
 * Copyright (C) 2011-2015 Incapture Technologies LLC
 *
 * This is an autogenerated license statement. When copyright notices appear below
 * this one that copyright supercedes this statement.
 *
 * Unless required by applicable law or agreed to in writing, software is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * Unless explicit permission obtained in writing this software cannot be distributed.
 */
package rapture.kernel.rabbit;

import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;
import org.junit.Test;

import rapture.common.RapturePipelineTask;
import rapture.common.model.RaptureExchange;
import rapture.common.model.RaptureExchangeQueue;
import rapture.common.model.RaptureExchangeType;
import rapture.exchange.ExchangeHandler;
import rapture.exchange.QueueHandler;
import rapture.exchange.rabbitmq.RabbitExchangeHandler;

/**
 * This is an integration test that relies on RabbitMQ server running on
 * localhost
 * 
 * @author bardhi
 * 
 */
public class RabbitExchangeTst {

    private static final Logger log = Logger.getLogger(RabbitExchangeTst.class);

    private static final Integer NUM_SENT = 1000;

    private static final String EXCHANGE_NAME = "testExchange1";
    private static final String QUEUE_PREFIX = "testQueue";

    private static final Integer NUM_CONSUMERS = 5; // let's have several
                                                    // consumers to
                                                    // make sure they all get
                                                    // the message
    final Map<String, Set<String>> receivedMessages = Collections.synchronizedMap(new HashMap<String, Set<String>>());
    final List<String> sentMessages = new ArrayList<String>(NUM_SENT);

    @Test
    public void testFanout() throws InterruptedException {

        Map<String, String> config = new HashMap<String, String>();
        RabbitExchangeHandler exchangeHandler = new RabbitExchangeHandler();
        exchangeHandler.setConfig(config);

        // Now create a config

        RaptureExchange exchangeConfig = new RaptureExchange();
        List<RaptureExchangeQueue> queueBindings = new LinkedList<RaptureExchangeQueue>();
        exchangeConfig.setQueueBindings(queueBindings);
        exchangeConfig.setName(EXCHANGE_NAME);
        exchangeConfig.setExchangeType(RaptureExchangeType.FANOUT);
        exchangeConfig.setName(EXCHANGE_NAME);

        for (Integer consumerId = 0; consumerId < NUM_CONSUMERS; consumerId++) {
            registerConsumer(consumerId, exchangeHandler, exchangeConfig);
        }
        exchangeHandler.setupExchange(exchangeConfig);
        sendMessages(exchangeHandler);
        startConsumingAll(exchangeHandler, exchangeConfig);
        Thread.sleep(3000);

        exchangeHandler.tearDownExchange(exchangeConfig);
        for (Integer consumerId = 0; consumerId < NUM_CONSUMERS; consumerId++) {
            String queueName = QUEUE_PREFIX + "-" + consumerId;
            Set<String> currMessages = receivedMessages.get(queueName);
            for (int messageIndex = 0; messageIndex < NUM_SENT; messageIndex++) {
                String expectedMessage = sentMessages.get(messageIndex);
                assertTrue(String.format("Queue queue %s does not contain message %s (index %s)", queueName, expectedMessage, messageIndex),
                        currMessages.contains(expectedMessage));
            }
        }
    }

    private void sendMessages(RabbitExchangeHandler exchangeHandler) {
        for (int i = 0; i < NUM_SENT; i++) {
            RapturePipelineTask pTask = new RapturePipelineTask();
            pTask.setPriority(1);
            pTask.setCategoryList(new ArrayList<String>());
            String content = "Message content #" + i;
            sentMessages.add(content);
            pTask.setContent(content);
            exchangeHandler.putTaskOnExchange(EXCHANGE_NAME, pTask, "");
        }

    }

    private void registerConsumer(final Integer consumerId, ExchangeHandler exchangeHandler, RaptureExchange exchangeConfig) {
        String queueName = QUEUE_PREFIX + "-" + consumerId;
        RaptureExchangeQueue queue = new RaptureExchangeQueue();
        queue.setName(queueName);
        queue.setRouteBindings(new ArrayList<String>());
        exchangeConfig.getQueueBindings().add(queue);

    }

    private void startConsumingAll(ExchangeHandler exchangeHandler, RaptureExchange exchangeConfig) {
        List<RaptureExchangeQueue> queues = exchangeConfig.getQueueBindings();
        for (RaptureExchangeQueue queue : queues) {
            final String queueName = queue.getName();
            final Set<String> currentMessages = Collections.synchronizedSet(new HashSet<String>(NUM_SENT));
            receivedMessages.put(queueName, currentMessages);
            exchangeHandler.startConsuming(EXCHANGE_NAME, queueName, new QueueHandler() {
                @Override
                public boolean handleMessage(String tag, String routing, String contentType, RapturePipelineTask task) {
                    String content = task.getContent();
                    currentMessages.add(content);
                    log.debug("Queue " + queueName + " received message with content='" + content + "', count is " + currentMessages.size());
                    return true;
                }

            });
        }

    }
}
