/**
 * Copyright (C) 2011-2015 Incapture Technologies LLC
 *
 * This is an autogenerated license statement. When copyright notices appear below
 * this one that copyright supercedes this statement.
 *
 * Unless required by applicable law or agreed to in writing, software is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * Unless explicit permission obtained in writing this software cannot be distributed.
 */
package rapture.repo.postgres;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;
import org.junit.Before;
import org.junit.Test;

import rapture.common.client.HttpLoginApi;
import rapture.common.client.HttpStructuredApi;
import rapture.common.client.SimpleCredentialsProvider;

import com.google.common.collect.ImmutableMap;

public class DemoTest {

    protected static final SimpleCredentialsProvider CREDENTIALS_PROVIDER = new SimpleCredentialsProvider("rapture", "rapture");

    private static final Logger log = Logger.getLogger(DemoTest.class);

    private HttpStructuredApi structured;

    private static final String schema = "demorepo";
    private static final String employees = "employees";
    private static final String addresses = "addresses";

    private static final String repoUri = "//" + schema;
    private static final String employeesUri = repoUri + "/" + employees;
    private static final String addressesUri = repoUri + "/" + addresses;

    @Before
    public void setup() {
        HttpLoginApi login = new HttpLoginApi("http://localhost:8665/rapture", CREDENTIALS_PROVIDER);
        login.login();
        structured = new HttpStructuredApi(login);
        if (structured.structuredRepoExists(repoUri)) {
            structured.deleteStructuredRepo(repoUri);
        }
        structured.createStructuredRepo(repoUri, "STRUCTURED {} USING POSTGRES {}");
    }

    @Test
    public void testBasicUsingSql() {
        int count = 100;
        String sql = String.format("CREATE TABLE IF NOT EXISTS %s.%s (id INT, street VARCHAR(30), city varchar(30), zip int)", schema, addresses);
        structured.createTableUsingSql(schema, sql);
        for (int i = 0; i < count; i++) {
            sql = String.format("INSERT INTO %s.%s (id, street, city, zip) VALUES (%d, 'street_%d', 'city_%d', %d)", schema, addresses, i, i, i, i);
            structured.insertUsingSql(schema, sql);
        }
        sql = String.format("SELECT * FROM %s.%s WHERE id < 100 ORDER BY id DESC LIMIT 10", schema, addresses);
        List<Map<String, Object>> rows = structured.selectUsingSql(schema, sql);
        assertEquals(10, rows.size());
        for (int i = 0; i < 10; i++) {
            Map<String, Object> row = rows.get(i);
            int x = 99 - i;
            assertEquals(4, row.size());
            assertEquals(x, row.get("id"));
            assertEquals("street_" + x, row.get("street"));
            assertEquals("city_" + x, row.get("city"));
            assertEquals(x, row.get("zip"));
        }
        structured.createIndex(addressesUri, "ID_INDEX", Arrays.asList("id"));
        sql = String.format("UPDATE %s.%s SET zip = 94127 WHERE id = 99", schema, addresses);
        structured.updateUsingSql(schema, sql);
        sql = String.format("SELECT zip FROM %s.%s WHERE id = 99", schema, addresses);
        rows = structured.selectUsingSql(schema, sql);
        assertEquals(1, rows.size());
        assertEquals(1, rows.get(0).size());
        assertEquals(94127, rows.get(0).get("zip"));
        sql = String.format("DELETE FROM %s.%s WHERE zip = 8127398", schema, addresses);
        structured.deleteUsingSql(schema, sql);
        sql = String.format("DELETE FROM %s.%s WHERE zip = 94127", schema, addresses);
        structured.deleteUsingSql(schema, sql);
        sql = String.format("SELECT * FROM %s.%s", schema, addresses);
        rows = structured.selectUsingSql(schema, sql);
        assertEquals(count - 1, rows.size());
    }

    @Test
    public void testBasicUsingArgs() {
        int count = 100;
        structured.createTable(employeesUri, ImmutableMap.of("id", "int", "name", "varchar(255)"));
        List<Map<String, Object>> values = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            values.add(ImmutableMap.<String, Object> of("id", i, "name", "name_" + i));
        }
        structured.insertRows(employeesUri, values);
        List<Map<String, Object>> rows = structured.selectRows(employeesUri, null, null, null, null, -1);
        assertEquals(count, rows.size());
        for (int i = 0; i < count; i++) {
            Map<String, Object> row = rows.get(i);
            assertEquals(2, row.size());
            assertEquals(i, row.get("id"));
            assertEquals("name_" + i, row.get("name"));
        }
        structured.addTableColumns(employeesUri, ImmutableMap.of("hiredate", "date", "terminationdate", "date"));
        structured.updateRows(employeesUri, ImmutableMap.<String, Object> of("hiredate", "2015-05-12"), null);
        rows = structured.selectRows(employeesUri, null, null, null, null, -1);
        assertEquals(count, rows.size());
        for (int i = 0; i < count; i++) {
            Map<String, Object> row = rows.get(i);
            assertEquals(4, row.size());
            assertEquals(i, row.get("id"));
            assertEquals("name_" + i, row.get("name"));
            assertEquals("2015-05-12", row.get("hiredate"));
            assertNull(row.get("terminationdate"));
        }
        structured.updateTableColumns(employeesUri, ImmutableMap.of("hiredate", "timestamp"));
        structured.deleteTableColumns(employeesUri, Arrays.asList("terminationdate"));
    }

    @Test
    public void testJoinsAndCursors() {
        int countEmployees = 100;
        int countAddresses = 50;
        structured.createTable(employeesUri, ImmutableMap.of("id", "int", "name", "varchar(255)"));
        List<Map<String, Object>> values = new ArrayList<>();
        for (int i = 0; i < countEmployees; i++) {
            values.add(ImmutableMap.<String, Object> of("id", i, "name", "name_" + i));
        }
        structured.insertRows(employeesUri, values);

        String sql = String.format("CREATE TABLE IF NOT EXISTS %s.%s (id INT, street VARCHAR(30), city varchar(30), zip int)", schema, addresses);
        structured.createTableUsingSql(schema, sql);
        for (int i = 0; i < countAddresses; i++) {
            sql = String.format("INSERT INTO %s.%s (id, street, city, zip) VALUES (%d, 'street_%d', 'city_%d', %d)", schema, addresses, i, i, i, i);
            structured.insertUsingSql(schema, sql);
        }

        structured.createIndex(employeesUri, employees + "_IDINDEX", Arrays.asList("id"));
        structured.createIndex(addressesUri, addresses + "_IDINDEX", Arrays.asList("id"));

        List<String> tables = Arrays.asList(employeesUri, addressesUri);
        List<String> columnNames = Arrays.asList(employees + ".id AS employee_id", employees + ".name as ename", addresses + ".city AS thecity");
        String from = String.format("%s.%s INNER JOIN %s.%s ON %s.id=%s.id", schema, employees, schema, addresses, employees, addresses);
        List<String> orderBy = Arrays.asList(String.format("%s.%s", employees, "id"));

        // SELECT employees.id AS employee_id, employees.name as ename, addresses.city AS thecity
        // FROM demorepo.employees
        // INNER JOIN demorepo.addresses ON employees.id=addresses.id
        // ORDER BY employees.id ASC

        List<Map<String, Object>> rows = structured.selectJoinedRows(tables, columnNames, from, null, orderBy, true, -1);
        assertEquals(countAddresses, rows.size());
        for (int i = 0; i < countAddresses; i++) {
            Map<String, Object> row = rows.get(i);
            assertEquals(3, row.size());
            assertEquals(i, row.get("employee_id"));
            assertEquals("name_" + i, row.get("ename"));
            assertEquals("city_" + i, row.get("thecity"));
        }

        from = String.format("%s.%s LEFT JOIN %s.%s ON %s.id=%s.id", schema, employees, schema, addresses, employees, addresses);

        // SELECT employees.id AS employee_id, employees.name as ename, addresses.city AS thecity
        // FROM demorepo.employees
        // LEFT JOIN demorepo.addresses ON employees.id=addresses.id
        // ORDER BY employees.id ASC

        rows = structured.selectJoinedRows(tables, columnNames, from, null, orderBy, true, -1);
        assertEquals(countEmployees, rows.size());
        for (int i = 0; i < countEmployees; i++) {
            Map<String, Object> row = rows.get(i);
            assertEquals(3, row.size());
            assertEquals(i, row.get("employee_id"));
            assertEquals("name_" + i, row.get("ename"));
            if (i < 50) {
                assertEquals("city_" + i, row.get("thecity"));
            } else {
                assertNull(row.get("thecity"));
            }
        }

        // SELECT employees.id AS employee_id, employees.name as ename, addresses.city AS thecity
        // FROM demorepo.employees
        // LEFT JOIN demorepo.addresses ON employees.id=addresses.id
        // WHERE employees.id < 5
        // ORDER BY employees.id ASC

        String cursorId = structured.getCursorForJoin(tables, columnNames, from, "employees.id < 5", orderBy, true, -1);
        rows = structured.next(employeesUri, cursorId, 2);
        assertEquals(2, rows.size());
        for (int i = 0; i < rows.size(); i++) {
            Map<String, Object> row = rows.get(i);
            assertEquals(3, row.size());
            assertEquals(i, row.get("employee_id"));
        }
        log.info(String.format("Cursor id is [%s]", cursorId));

    }
}
