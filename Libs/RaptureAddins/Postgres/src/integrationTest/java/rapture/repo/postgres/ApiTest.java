/**
 * Copyright (C) 2011-2015 Incapture Technologies LLC
 *
 * This is an autogenerated license statement. When copyright notices appear below
 * this one that copyright supercedes this statement.
 *
 * Unless required by applicable law or agreed to in writing, software is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * Unless explicit permission obtained in writing this software cannot be distributed.
 */
package rapture.repo.postgres;

import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;
import org.junit.Before;
import org.junit.Test;

import rapture.common.RaptureURI;
import rapture.common.RaptureURI.Parser;
import rapture.common.Scheme;
import rapture.common.client.HttpLoginApi;
import rapture.common.client.HttpStructuredApi;
import rapture.common.client.SimpleCredentialsProvider;

import com.google.common.collect.ImmutableMap;

public class ApiTest {

    protected static final SimpleCredentialsProvider CREDENTIALS_PROVIDER = new SimpleCredentialsProvider("x", "x");

    private static final Logger log = Logger.getLogger(ApiTest.class);

    private HttpStructuredApi struct;

    private String repo = "//structuredTest1";
    private String table1 = repo + "/table1";

    @Before
    public void setup() {
        String host = "http://localhost:8665/rapture";
        System.out.println("host = " + host);
        HttpLoginApi login = new HttpLoginApi(host, CREDENTIALS_PROVIDER);
        login.login();
        struct = new HttpStructuredApi(login);
    }

    @Test
    public void test() {

        if (!struct.structuredRepoExists(repo)) {
            log.info("Creating structured repo: " + repo);
            struct.createStructuredRepo(repo, "STRUCTURED {} USING POSTGRES {}");
        }
        struct.createTable(table1, ImmutableMap.of("id", "int", "name", "varchar(255)"));

        List<Map<String, Object>> vals = new ArrayList<Map<String, Object>>();
        for (int i = 0; i < 100; i++) {
            Map<String, Object> m = new HashMap<>();
            m.put("id", i);
            m.put("name", "name_" + i);
            vals.add(m);
        }
        struct.insertRows(table1, vals);

    }

    @Test
    public void testQry() {
        List<Map<String, Object>> res = struct.selectRows(table1, null, null, null, null, -1);
        for (Map<String, Object> r : res) {
            System.out.println(r.get("name"));
        }
    }

    @Test
    public void testDdl() {
        System.out.println(struct.getDdl(repo, true));
    }

    @Test
    public void testDrop() {
        struct.deleteStructuredRepo("//structuredTest1");

    }

    @Test
    public void testRuri() {
        RaptureURI r1 = RaptureURI.builder(Scheme.DOCUMENT, "test").docPath("").build();
        RaptureURI r2 = new RaptureURI("//test", Scheme.DOCUMENT);
        System.out.println(r1.equals(r2));

        String fullPath = "structuredTest1/";
        int sliceCount = 2;
        String[] parts = fullPath.split(Parser.SEPARATOR_CHAR.toString(), sliceCount);
        System.out.println(parts[0]);
        System.out.println("[" + parts[1] + "]");
    }
}
