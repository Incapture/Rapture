/**
 * Copyright (C) 2011-2013 Incapture Technologies LLC
 * 
 * This is an autogenerated license statement. When copyright notices appear below
 * this one that copyright supercedes this statement.
 *
 * Unless required by applicable law or agreed to in writing, software is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * Unless explicit permission obtained in writing this software cannot be distributed.
 */

/**
 * This is an autogenerated file. You should not edit this file as any changes
 * will be overwritten.
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using DotNetRaptureAPI.Common.FixedTypes;

namespace DotNetRaptureAPI
{
    public interface DecisionApi {
     /**
     * Returns all workflow definitions
     * 
     */
     List<Workflow> getAllWorkflows(CallingContext context);

     /**
     * Returns a list of full display names of the paths below this one. Ideally optimized depending on the repo.
     * 
     */
     List<RaptureFolderInfo> getWorkflowChildren(CallingContext context, string workflowURI);

     /**
     * Return a list of full display names of the paths below this one. Ideally optimized depending on the repo.
     * 
     */
     List<RaptureFolderInfo> getWorkOrderChildren(CallingContext context, string parentPath);

     /**
     * Create or update a workflow to contain only the specified nodes and transitions.
     * 
     */
     void putWorkflow(CallingContext context, Workflow workflow);

     /**
     * Returns a workflow definition, or null if not found.
     * 
     */
     Workflow getWorkflow(CallingContext context, string workflowURI);

     /**
     * Returns a step definition, or null if not found
     * 
     */
     Step getWorkflowStep(CallingContext context, string stepURI);

     /**
     * Gets the category associated with a step. This is the step's own categoryOverride, if present, or otherwise the category associated with the entire workflow.
     * 
     */
     string getStepCategory(CallingContext context, string stepURI);

     /**
     * Adds a new step to an existing workflow initially containing the specified transitions
     * 
     */
     void addStep(CallingContext context, string workflowURI, Step step);

     /**
     * Removes a step from a workflow.
     * 
     */
     void removeStep(CallingContext context, string workflowURI, string stepName);

     /**
     * Adds a new Transition to a workflow.
     * 
     */
     void addTransition(CallingContext context, string workflowURI, string stepName, Transition transition);

     /**
     * Removes a transition from a workflow.
     * 
     */
     void removeTransition(CallingContext context, string workflowURI, string stepName, string transitionName);

     /**
     * Deletes a workflow.
     * 
     */
     void deleteWorkflow(CallingContext context, string workflowURI);

     /**
     * Creates a workflow step template
     * 
     */
     void putWorkflowStepTemplate(CallingContext context, WorkflowStepTemplate template);

     /**
     * Retrieve a workflow step template
     * 
     */
     WorkflowStepTemplate getWorkflowStepTemplate(CallingContext context, string workflowStepTemplateURI);

     /**
     * Deletes a workflow step template
     * 
     */
     void deleteWorkflowStepTemplate(CallingContext context, string workflowStepTemplateURI);

     /**
     * Return a list of full display names of the paths below this one. Ideally optimized depending on the repo.
     * 
     */
     List<RaptureFolderInfo> getWorflowStepTemplateChildren(CallingContext context, string parentPath);

     /**
     * Creates and executes a workflow. 
         If there is a defaultAppStatusUriPattern set for this Workflow then it will be used for the appstatus URI.
         Otherwise, no appstatus will be created.
         TODO make workOrderURI format align with permission checks.
     * 
     */
     string createWorkOrder(CallingContext context, string workflowURI, Dictionary<string, string> argsMap);

     /**
     * Creates and executes a workflow. Same as createWorkOrder, but the appStatusUriPattern is passed as an explicit argument instead of using the default appStatusUriPattern (if one has been set).
         Note that the app status allows the Workflow and its output to be accessed via the web interface; workflows without an app status are not accessible in this way. 
     * 
     */
     CreateResponse createWorkOrderP(CallingContext context, string workflowURI, Dictionary<string, string> argsMap, string appStatusUriPattern);

     /**
     * Releases the lock associated with this WorkOrder. This method should only be used by admins, in case there
         was an unexpected problem that caused a WorkOrder to finish or die without releasing the lock.
     * 
     */
     void releaseWorkOrderLock(CallingContext context, string workOrderURI);

     /**
     * Gets the status of a workOrder
     * 
     */
     WorkOrderStatus getWorkOrderStatus(CallingContext context, string workOrderURI);

     /**
     * Writes an audit entry related to a workOrder. Messages may be INFO or ERROR based on the boolean fourth parameter
     * 
     */
     void writeWorkflowAuditEntry(CallingContext context, string workOrderURI, string message, bool error);

     /**
     * Gets the WorkOrder objects starting on a given day. Orders that carried over from the previous day are not included. 
     * 
     */
     List<WorkOrder> getWorkOrdersByDay(CallingContext context, long startTimeInstant);

     /**
     * Gets the top-level status object associated with the work order
     * 
     */
     WorkOrder getWorkOrder(CallingContext context, string workOrderURI);

     /**
     * Get the worker
     * 
     */
     Worker getWorker(CallingContext context, string workOrderURI, string workerId);

     /**
     * Requests cancellation of a work order. This method returns immediately once the cancellation is recorded, but the individual workers may continue for some time before stopping, depending on the type of step being executed.
     * 
     */
     void cancelWorkOrder(CallingContext context, string workOrderURI);

     /**
     * Resume work order
     * 
     */
     CreateResponse resumeWorkOrder(CallingContext context, string workOrderURI, string resumeStepURI);

     /**
     * Returns true if CancelWorkOrder was called.
     * 
     */
     bool wasCancelCalled(CallingContext context, string workOrderURI);

     /**
     * Gets details for the cancellation for a workOrder -- or null if not cancelled.
     * 
     */
     WorkOrderCancellation getCancellationDetails(CallingContext context, string workOrderURI);

     /**
     * Gets the detailed context information for a work order in progress
     * 
     */
     WorkOrderDebug getWorkOrderDebug(CallingContext context, string workOrderURI);

     /**
     * Defines the IdGen config for work order items.
     * 
     */
     void setWorkOrderIdGenConfig(CallingContext context, string config, bool force);

     /**
     * Sets a literal in the context. The literal value that is stored will be returned after a read. 
         The workerURI is a workOrderURI with the element set to the worker ID.
     * 
     */
     void setContextLiteral(CallingContext context, string workerURI, string varAlias, string literalValue);

     /**
     * Set a literal in the context. This means that whatever is stored will be evaluated before being returned, so it must be a valid expression. 
         The workerURI is a workOrderURI with the element set to the worker id
     * 
     */
     void setContextLink(CallingContext context, string workerURI, string varAlias, string expressionValue);

     /**
     * Gets a value in the context, as json. The workerURI is a workOrderURI with the element set to the worker id.
     * 
     */
     string getContextValue(CallingContext context, string workerURI, string varAlias);

     /**
     * Adds an error to the context of a particular worker. The workerURI is a workOrderURI with the element set to the worker id
     * 
     */
     void addErrorToContext(CallingContext context, string workerURI, ErrorWrapper errorWrapper);

     /**
     * Gets the errors from the context for a given worker. The workerURI is a workOrderURI with the element set to the worker id.
     * 
     */
     List<ErrorWrapper> getErrorsFromContext(CallingContext context, string workerURI);

     /**
     * Get info about any exception(s) thrown during execution of this workorder
     * 
     */
     List<ErrorWrapper> getExceptionInfo(CallingContext context, string workOrderURI);

     /**
     * Report status of the step
          - workerURI: the uri of this WorkOrder with the element set to the worker ID
          - stepStartTime: the time when the step being reported started
          - message: a human-friendly message to display
          - progress: how many units are currently complete
          - max: how many units in total would mark this as done
         
     * 
     */
     void reportStepProgress(CallingContext context, string workerURI, long stepStartTime, string message, long progress, long max);

     /**
     * Gets app statuses by prefix.
     * 
     */
     List<AppStatus> getAppStatuses(CallingContext context, string prefix);

     /**
     * Gets detailed app status info by prefix. Also returns any context values requested in the second argument.
     * 
     */
     List<AppStatusDetails> getAppStatusDetails(CallingContext context, string prefix, List<string> extraContextValues);

     /**
     * Get any defined average runtimes for the past month for a workflow
     * 
     */
     WorkflowHistoricalMetrics getMonthlyMetrics(CallingContext context, string workflowURI, string jobURI, string argsHashValue, string state);

     /**
     * Get log messages for a workflow. Note: logs get deleted after a certain number of days, so this only retrieves any log messages that are within the
         configured log retention period. If the retention period is before the startTime, an empty response is returned.
         workOrderURI: required
         startTime: required
         endTime: required
         keepAlive: required, milliseconds to keep alive the batch, max 30000
         bufferSize: required, max 100
         nextBatchId: optional, if null start from beginning
         stepName: optional
         stepStartTime: optional, this is a timestamp in a string because of a limitation in Rapture where int or long arguments cannot be null
         
     * 
     */
     LogQueryResponse queryLogs(CallingContext context, string workOrderURI, long startTime, long endTime, long keepAlive, long bufferSize, string nextBatchId, string stepName, string stepStartTime);

	}
}

