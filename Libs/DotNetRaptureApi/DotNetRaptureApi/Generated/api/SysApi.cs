/**
 * Copyright (C) 2011-2013 Incapture Technologies LLC
 * 
 * This is an autogenerated license statement. When copyright notices appear below
 * this one that copyright supercedes this statement.
 *
 * Unless required by applicable law or agreed to in writing, software is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * Unless explicit permission obtained in writing this software cannot be distributed.
 */

/**
 * This is an autogenerated file. You should not edit this file as any changes
 * will be overwritten.
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using DotNetRaptureAPI.Common.FixedTypes;

namespace DotNetRaptureAPI
{
    public interface SysApi {
     /**
     * Retrieve a system config
     * 
     */
     string retrieveSystemConfig(CallingContext context, string area, string path);

     /**
     * Write a system config
     * 
     */
     string writeSystemConfig(CallingContext context, string area, string path, string content);

     /**
     * Remove a system document
     * 
     */
     void removeSystemConfig(CallingContext context, string area, string path);

     /**
     * Gets the hiearchy (the documents below this point, like with user.getChildren)
     * 
     */
     List<RaptureFolderInfo> getSystemFolders(CallingContext context, string area, string path);

     /**
     * Retrieve all top level repos 
     * 
     */
     List<string> getAllTopLevelRepos(CallingContext context);

     /**
     * Get children from the specified point.
         
         URI Cannot be null, but it can be the IndexMark from the ChildrenTransferObject returned by a previous call.
         depth indicates the number of levels to retrieve data for.
         If maximum > 0 then cap the number of entries returned
         
         if refresh is false and there are more results than the defined maximum then store the remainder in the cache for quick access next time
               
          If refresh is true and there are more results than the defined maximum then keep track of the values that have been returned.
          On the next call re-read the tree and return only new entries. 
          This is much slower than without refresh because the tree is re-read each time. 
     * 
     */
     ChildrenTransferObject listByUriPrefix(CallingContext context, string raptureURI, string marker, int depth, long maximum, bool refresh);

     /**
     * Retrieve all the immediate children of a URI
     * 
     */
     ChildrenTransferObject getChildren(CallingContext context, string raptureURI);

     /**
     * Retrieve all the children of a URI, spanning multiple levels. The page size must be specified.
          If refresh is false and there are more results than the defined page size then store the remainder in the cache for quick access next time

          If refresh is true and there are more results than the defined maximum then keep track of the values that have been returned.
          On the next call re-read the tree and return only new entries.
          This is slower than without refresh because the tree is re-read each time.
     * 
     */
     ChildrenTransferObject getAllChildren(CallingContext context, string raptureURI, string marker, long maximum, bool refresh);

     /**
     * Determine whether the URI references an object, a folder, both or neither
     * 
     */
     NodeEnum getFolderInfo(CallingContext context, string raptureURI);

	}
}

