/**
 * Copyright (C) 2011-2013 Incapture Technologies LLC
 * 
 * This is an autogenerated license statement. When copyright notices appear below
 * this one that copyright supercedes this statement.
 *
 * Unless required by applicable law or agreed to in writing, software is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * Unless explicit permission obtained in writing this software cannot be distributed.
 */

/**
 * This is an autogenerated file. You should not edit this file as any changes
 * will be overwritten.
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using DotNetRaptureAPI.Common.FixedTypes;

namespace DotNetRaptureAPI
{
    public interface RunnerApi {
     /**
     *  Creates a new server group. 
     * 
     */
     RaptureServerGroup createServerGroup(CallingContext context, string name, string description);

     /**
     *  Remove a server group (and all of its application definitions ) 
     * 
     */
     void deleteServerGroup(CallingContext context, string name);

     /**
     *  Returns all server groups defined in Rapture. 
     * 
     */
     List<RaptureServerGroup> getAllServerGroups(CallingContext context);

     /**
     * Returns a list of all the applications defined in Rapture, which Rapture Runner knows about, including their versions. This is the list of applications that Rapture is aware of, but it does not necessarily run everything. To get a list of what will be running, look at getAllApplicationInstances.
     * 
     */
     List<RaptureApplicationDefinition> getAllApplicationDefinitions(CallingContext context);

     /**
     * Get a list of all libraries defined in Rapture. These are also known as Rapture add-ons, or plugins.
     * 
     */
     List<RaptureLibraryDefinition> getAllLibraryDefinitions(CallingContext context);

     /**
     * Retrieves all the application instances defined in Rapture. This is really the list of schedule entries, meaning every application-server group combination that is scheduled to run.
     * 
     */
     List<RaptureApplicationInstance> getAllApplicationInstances(CallingContext context);

     /**
     *  Retrieves a server group object, or null if no such object was found. 
     * 
     */
     RaptureServerGroup getServerGroup(CallingContext context, string name);

     /**
     * Add a server group inclusion. An inclusion is a hostname where this server group should run. By default, this is set to *, which means run everywhere. Adding an inclusion makes it so that this server group will run only on certain servers.
     * 
     */
     RaptureServerGroup addGroupInclusion(CallingContext context, string name, string inclusion);

     /**
     * Removes a server group inclusion. Refer to AddGroupInclusion for more details.
     * 
     */
     RaptureServerGroup removeGroupInclusion(CallingContext context, string name, string inclusion);

     /**
     * Add a server group exclusion. An exclusion is a hostname where this server group should not run. By default, this is set to empty, which means run on every host specified in inclusions. It makes more sense to add an exclusion if this server group has a wildcard (*) for inclusions. See also addGroupInclusion.
     * 
     */
     RaptureServerGroup addGroupExclusion(CallingContext context, string name, string exclusion);

     /**
     * Removes a server group exclusion. Refer to AddGroupExclusion for more details.
     * 
     */
     RaptureServerGroup removeGroupExclusion(CallingContext context, string name, string exclusion);

     /**
     * Remove an entry from either an exclusion or inclusion 
     * 
     */
     RaptureServerGroup removeGroupEntry(CallingContext context, string name, string entry);

     /**
     * Creates an application definition.
     * 
     */
     RaptureApplicationDefinition createApplicationDefinition(CallingContext context, string name, string ver, string description);

     /**
     * Delete an application definition (and any references in server groups)
     * 
     */
     void deleteApplicationDefinition(CallingContext context, string name);

     /**
     * Update a version of an application
     * 
     */
     RaptureApplicationDefinition updateApplicationVersion(CallingContext context, string name, string ver);

     /**
     * Creates an application library. See also getAllLibraryDefinitions.
     * 
     */
     RaptureLibraryDefinition createLibraryDefinition(CallingContext context, string name, string ver, string description);

     /**
     * Remove a library definition (and any references in server groups)
     * 
     */
     void deleteLibraryDefinition(CallingContext context, string name);

     /**
     * Retrieve an library definition
     * 
     */
     RaptureLibraryDefinition getLibraryDefinition(CallingContext context, string name);

     /**
     * Update a version of a library
     * 
     */
     RaptureLibraryDefinition updateLibraryVersion(CallingContext context, string name, string ver);

     /**
     * Associates a library with a server group.
     * 
     */
     RaptureServerGroup addLibraryToGroup(CallingContext context, string serverGroup, string libraryName);

     /**
     * Remove the association between a library and a server group
     * 
     */
     RaptureServerGroup removeLibraryFromGroup(CallingContext context, string serverGroup, string libraryName);

     /**
     * Adds an association between an application and a server group. This is the way to tell Rapture that a certain application needs to run (or be scheduled to run at given hours) as part of a server group.
     * 
     */
     RaptureApplicationInstance createApplicationInstance(CallingContext context, string name, string description, string serverGroup, string appName, string timeRange, int retryCount, string parameters, string apiUser);

     /**
     * Start a batch/single process (ultimately to replace the oneshot calls).
     * 
     */
     RaptureApplicationStatus runApplication(CallingContext context, string appName, string queueName, Dictionary<string, string> parameterInput, Dictionary<string, string> parameterOutput);

     /**
     * Start a batch/single process (ultimately to replace the oneshot calls)s.
     * 
     */
     RaptureApplicationStatus runCustomApplication(CallingContext context, string appName, string queueName, Dictionary<string, string> parameterInput, Dictionary<string, string> parameterOutput, string customApplicationPath);

     /**
     * Returns a status object that shows the current state of the app.
     * 
     */
     RaptureApplicationStatus getApplicationStatus(CallingContext context, string applicationStatusURI);

     /**
     * Lists the apps that are interesting, given a QBE template (empty strings have default behavior).
     * 
     */
     List<RaptureApplicationStatus> getApplicationStatuses(CallingContext context, string date);

     /**
     * Lists the dates for which statuses exist.
     * 
     */
     List<string> getApplicationStatusDates(CallingContext context);

     /**
     * Tidy up old status invocations
     * 
     */
     void archiveApplicationStatuses(CallingContext context);

     /**
     * Update the status of an application instance.
     * 
     */
     RaptureApplicationStatus changeApplicationStatus(CallingContext context, string applicationStatusURI, RaptureApplicationStatusStep statusCode, string message);

     /**
     * Adds messages to a running application instance.
     * 
     */
     void recordStatusMessages(CallingContext context, string applicationStatusURI, List<string> messages);

     /**
     * Attempts to cancel the execution of an application.
     * 
     */
     RaptureApplicationStatus terminateApplication(CallingContext context, string applicationStatusURI, string reasonMessage);

     /**
     * Delete an application instance
     * 
     */
     void deleteApplicationInstance(CallingContext context, string name, string serverGroup);

     /**
     * Retrieve an application instance
     * 
     */
     RaptureApplicationInstance getApplicationInstance(CallingContext context, string name, string serverGroup);

     /**
     * Update the status of a one shot execution, potentially marking it as finished
     * 
     */
     void updateStatus(CallingContext context, string name, string serverGroup, string myServer, string status, bool finished);

     /**
     * Returns a list of application instance (aka schedule) names that are configured to run as part of a specific server group.
     * 
     */
     List<string> getApplicationsForServerGroup(CallingContext context, string serverGroup);

     /**
     * Returns a list of applications that should run on a specific host (aka server). Servers are defined in inclusions; see addGroupInclusion for more details. All applications that will run on a given server will be returned. Applications belonging to a server group that includes all servers via the * wildcard will also be returned.
     * 
     */
     List<RaptureApplicationInstance> getApplicationsForServer(CallingContext context, string serverName);

     /**
     * Retrieve an application definition
     * 
     */
     RaptureApplicationDefinition getApplicationDefinition(CallingContext context, string name);

     /**
     * Set a config variable available in RaptureRunner. The config variables understood are APPSOURCE and MODSOURCE, and they specify the location of the apps and libraries controlled by RaptureRunner.
     * 
     */
     void setRunnerConfig(CallingContext context, string name, string value);

     /**
     * Removes a variable from the Runner config.
     * 
     */
     void deleteRunnerConfig(CallingContext context, string name);

     /**
     * Returns the RaptureRunnerConfig object, which contains the values of the variables configured via setRunnerConfig.
     * 
     */
     RaptureRunnerConfig getRunnerConfig(CallingContext context);

     /**
     * Records the status of an application instance by acquiring a lock based on the server name, similar to the behavior of cleanRunnerStatus and markForRestart.
     * 
     */
     void recordRunnerStatus(CallingContext context, string serverName, string serverGroup, string appInstance, string appName, string status);

     /**
     * Each RaptureApplicationInstance has certain capabilities associated with it. These could be queried by other apps if necessary (see getCapabilities). For example, the RaptureAPIServer has a capability to handle api calls, and it posts its api uri, including port, as a capability, that other apps can retrieve if they want to contact the api directly. This method will record capabilities for a given instance.
     * 
     */
     void recordInstanceCapabilities(CallingContext context, string serverName, string instanceName, Dictionary<string, Object> capabilities);

     /**
     * Returns the capabilities for one or more instance running on the specified host. See also recordInstanceCapabilities.
     * 
     */
     Dictionary<string, RaptureInstanceCapabilities> getCapabilities(CallingContext context, string serverName, List<string> instanceNames);

     /**
     * Gets a list of all the known server names (aka hostnames). This is determined by finding where a RaptureRunner is currently running or has run in the past and recorded a status (which has not been deleted), whether it be up or down.
     * 
     */
     List<string> getRunnerServers(CallingContext context);

     /**
     * Get a RaptureRunnerStatus object for one specific host, which is a map of the statuses of all instances on a specific host.
     * 
     */
     RaptureRunnerStatus getRunnerStatus(CallingContext context, string serverName);

     /**
     * Cleans out old status information, older than the passed parameter in minutes. It acquires a lock based on the server name, same as recordRunnerStatus and markForRestart.
     * 
     */
     void cleanRunnerStatus(CallingContext context, int ageInMinutes);

     /**
     * Marks a running instance as needing reboot. If an application is not found as running on the specified server, nothing is done. This will not start a server that is not running. This acquires a lock based on the server name, same as recordRunnerStatus and cleanRunnerStatus.
     * 
     */
     void markForRestart(CallingContext context, string serverName, string name);

	}
}

