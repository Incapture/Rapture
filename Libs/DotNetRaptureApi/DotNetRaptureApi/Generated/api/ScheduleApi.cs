/**
 * Copyright (C) 2011-2013 Incapture Technologies LLC
 * 
 * This is an autogenerated license statement. When copyright notices appear below
 * this one that copyright supercedes this statement.
 *
 * Unless required by applicable law or agreed to in writing, software is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * Unless explicit permission obtained in writing this software cannot be distributed.
 */

/**
 * This is an autogenerated file. You should not edit this file as any changes
 * will be overwritten.
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using DotNetRaptureAPI.Common.FixedTypes;

namespace DotNetRaptureAPI
{
    public interface ScheduleApi {
     /**
     * Creates a new job. The executableURI should point to a RaptureScript. 
         A job needs to be activated for it be available for execution. A job can be either auto-activate (i.e. it is activated, 
         then de-activated while it runs, then activated on completion. OR it can be not-auto-activate, whereupon it needs to be activated
         manually, by either a predecessor job (a job that has this job as a dependency) or manually via the activate schedule API call.
     * 
     */
     RaptureJob createJob(CallingContext context, string jobURI, string description, string scriptURI, string cronExpression, string timeZone, Dictionary<string, string> jobParams, bool autoActivate);

     /**
     * Creates a new Workflow-based job. The executableURI should point to a Workflow. A WorkOrder will be created
         when the job is executed. The jobParams will be passed in to the Workflow as the contextMap.
         The maxRuntimeMinutes will be used to throw alerts when the job runs longer than expected.
         A job needs to be activated for it be available for execution. A job can be either auto-activate (i.e. it is activated, 
         then de-activated while it runs, then activated on completion. OR it can be not-auto-activate, whereupon it needs to be activated
         manually, by either a predecessor job (a job that has this job as a dependency) or manually via the activate schedule API call.
     * 
     */
     RaptureJob createWorkflowJob(CallingContext context, string jobURI, string description, string workflowURI, string cronExpression, string timeZone, Dictionary<string, string> jobParams, bool autoActivate, int maxRuntimeMinutes, string appStatusNamePattern);

     /**
     * Activate a job (usually that is not auto-activate). This means that the job will now be picked up by the scheduler and executed at whatever time it is configured to run.
     * 
     */
     void activateJob(CallingContext context, string jobURI, Dictionary<string, string> extraParams);

     /**
     * Turns off a job's schedule-based execution.
     * 
     */
     void deactivateJob(CallingContext context, string jobURI);

     /**
     * Retrieve the definition of a job given its URI.
     * 
     */
     RaptureJob retrieveJob(CallingContext context, string jobURI);

     /**
     * Retrieve the definition of all jobs in the system whose uri starts with a certain prefix (e.g job://my/jobs/date1) 
     * 
     */
     List<RaptureJob> retrieveJobs(CallingContext context, string uriPrefix);

     /**
     * Try to schedule this job to run as soon as possible.
     * 
     */
     void runJobNow(CallingContext context, string jobURI, Dictionary<string, string> extraParams);

     /**
     * Removes the upcoming scheduled execution of this job and schedules it to run according to the cron in the job configuration.
     * 
     */
     void resetJob(CallingContext context, string jobURI);

     /**
     * Retrieves the execution of a job.
     * 
     */
     RaptureJobExec retrieveJobExec(CallingContext context, string jobURI, long execTime);

     /**
     * Removes a job from the system.
     * 
     */
     void deleteJob(CallingContext context, string jobURI);

     /**
     * Retrieves all of the JobURI addresses of the jobs in the system.
     * 
     */
     List<string> getJobs(CallingContext context);

     /**
     * Retrieves all of the upcoming jobs in the system.
     * 
     */
     List<RaptureJobExec> getUpcomingJobs(CallingContext context);

     /**
     * Retrieves the status of all current workflow-based job executions. This looks into the last execution as well as upcoming execution for all scheduled jobs. The return object contains a list of jobs that succeeded, failed, are overrun, or are ok (i.e. either scheduled to start in the future or currently running but not overrun). For failed or overrun jobs, information is also returned as to whether the failure/overrun has been acknowledged. See also ackJobError.
     * 
     */
     WorkflowExecsStatus getWorkflowExecsStatus(CallingContext context);

     /**
     * Acknowledges a job failure, storing the acknowledgment in Rapture. This information is returned when retrieving job statuses. See also getWorkflowExecsStatus.
     * 
     */
     JobErrorAck ackJobError(CallingContext context, string jobURI, long execTime, string jobErrorType);

     /**
     * Gets the next execution time for a given job.
     * 
     */
     RaptureJobExec getNextExec(CallingContext context, string jobURI);

     /**
     * Retrieves a list of job executions in a given range.
     * 
     */
     List<RaptureJobExec> getJobExecs(CallingContext context, string jobURI, int start, int count, bool reversed);

     /**
     * Retrieve a list of job executions for a list of jobs. This will return the job executions starting at index start (inclusive), and going on
         for count. If reverse is true, it starts from the end.
     * 
     */
     List<RaptureJobExec> batchGetJobExecs(CallingContext context, List<string> jobURI, int start, int count, bool reversed);

     /**
     * Return whether the given job is ready to run.
     * 
     */
     bool isJobReadyToRun(CallingContext context, string toJobURI);

     /**
     * For TimeServer, get a list of scheduled events for this week (starts on Sunday, use offset to look at next week)
     * 
     */
     List<TimedEventRecord> getCurrentWeekTimeRecords(CallingContext context, int weekOffsetfromNow);

     /**
     * For TimeServer, get a list of scheduled jobs for the current day
     * 
     */
     List<TimedEventRecord> getCurrentDayJobs(CallingContext context);

	}
}

