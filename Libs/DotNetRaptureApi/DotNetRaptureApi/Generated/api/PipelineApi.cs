/**
 * Copyright (C) 2011-2013 Incapture Technologies LLC
 * 
 * This is an autogenerated license statement. When copyright notices appear below
 * this one that copyright supercedes this statement.
 *
 * Unless required by applicable law or agreed to in writing, software is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * Unless explicit permission obtained in writing this software cannot be distributed.
 */

/**
 * This is an autogenerated file. You should not edit this file as any changes
 * will be overwritten.
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using DotNetRaptureAPI.Common.FixedTypes;

namespace DotNetRaptureAPI
{
    public interface PipelineApi {
     /**
     * Deletes a given category.
     * 
     */
     void removeServerCategory(CallingContext context, string category);

     /**
     * List server categories.
     * 
     */
     List<string> getServerCategories(CallingContext context);

     /**
     * Get bound exchanges for a category
     * 
     */
     List<CategoryQueueBindings> getBoundExchanges(CallingContext context, string category);

     /**
     * Removes an exchange.
     * 
     */
     void deregisterPipelineExchange(CallingContext context, string name);

     /**
     * Retrieves all registered exchanges.
     * 
     */
     List<string> getExchanges(CallingContext context);

     /**
     * Retrieves an exchange object by name.
     * 
     */
     RaptureExchange getExchange(CallingContext context, string name);

     /**
     * Publishes a message. This message will be published to the category specified in the RapturePipelineTask object.
        If no category is specified, an error is thrown. This type of message should be handled by only one of
        the servers belonging to this category; in other words, it is not a broadcast.
     * 
     */
     void publishMessageToCategory(CallingContext context, RapturePipelineTask task);

     /**
     * This message will be broadcasted to all servers belonging to the category specified in the RapturePipelineTask
         object. If no category is specified, an error is thrown.
     * 
     */
     void broadcastMessageToCategory(CallingContext context, RapturePipelineTask task);

     /**
     * This message will be broadcasted to all servers connected to the pipeline system.
     * 
     */
     void broadcastMessageToAll(CallingContext context, RapturePipelineTask task);

     /**
     * Gets the status for a published RapturePipelineTask.
     * 
     */
     PipelineTaskStatus getStatus(CallingContext context, string taskId);

     /**
     * Queries for pipeline statuses.
     * 
     */
     List<RapturePipelineTask> queryTasks(CallingContext context, string query);

     /**
     * Queries for pipeline statuses.
     * 
     */
     List<RapturePipelineTask> queryTasksOld(CallingContext context, TableQuery query);

     /**
     * On the task information, get the latest epoch (the maximum message id).
     * 
     */
     long getLatestTaskEpoch(CallingContext context);

     /**
     * Drain an exchange - remove all messages.
     * 
     */
     void drainPipeline(CallingContext context, string exchange);

     /**
     * Registers a new exchange domain.
     * 
     */
     void registerExchangeDomain(CallingContext context, string domainURI, string config);

     /**
     * Removes an exchange domain.
     * 
     */
     void deregisterExchangeDomain(CallingContext context, string domainURI);

     /**
     * Retrieves all registered exchange domains.
     * 
     */
     List<string> getExchangeDomains(CallingContext context);

     /**
     * Sets up the default queue-exchanges and bindings for a given category.
     * 
     */
     void setupStandardCategory(CallingContext context, string category);

     /**
     * Make an RPC call using a pair of queues on the pipeline of the default exchange. I notice
          that the exchange is removed from the above call which seems to be a bit of a regression
     * 
     */
     Dictionary<string, Object> makeRPC(CallingContext context, string queueName, string fnName, Dictionary<string, Object> rparams, long timeoutInSeconds);

     /**
     * Create a topic exchange that can be used to pub/sub on
     * 
     */
     void createTopicExchange(CallingContext context, string domain, string exchange);

     /**
     * Publish on topic exchange (Subscription has to go low level)
     * 
     */
     void publishTopicMessage(CallingContext context, string domain, string exchange, string topic, string message);

	}
}

