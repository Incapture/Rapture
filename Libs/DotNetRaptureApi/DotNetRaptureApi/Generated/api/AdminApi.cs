/**
 * Copyright (C) 2011-2013 Incapture Technologies LLC
 * 
 * This is an autogenerated license statement. When copyright notices appear below
 * this one that copyright supercedes this statement.
 *
 * Unless required by applicable law or agreed to in writing, software is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * Unless explicit permission obtained in writing this software cannot be distributed.
 */

/**
 * This is an autogenerated file. You should not edit this file as any changes
 * will be overwritten.
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using DotNetRaptureAPI.Common.FixedTypes;

namespace DotNetRaptureAPI
{
    public interface AdminApi {
     /**
     * This function retrieves the system properties in use for this instance of Rapture. As system properties
         are often used to control external connectivity, a client can determine the inferred connectivity endpoints
         by using this api call. It returns a map from system property name (the key) to value. You cannot modify the
         system properties of Rapture through the api, they are set by the administrator as part of the general setup of a Rapture
         system. Note that this call returns the properties for the actual end point that the client is connected to, it is not necessarily true that
         the same properties will be set for every API endpoint.
     * 
     */
     Dictionary<string, string> getSystemProperties(CallingContext context, List<string> keys);

     /**
     * Rapture is a hierarchical set of repositories, and this method returns the config of the top most level - that used
         for general config and temporary (transient) values such as sessions. In clustered mode these configs would
         be referencing shared storage, and in test mode they would normally refer to in-memory versions of the config. 
         The manipulation of the top level config can be performed through the Bootstrap API.
     * 
     */
     List<RepoConfig> getRepoConfig(CallingContext context);

     /**
     * When a user logs into Rapture they create a transient session and this method is a way of 
         retrieving all of the sessions for a given user. The CallingContext is a common object 
         passed around Rapture api calls.
     * 
     */
     List<CallingContext> getSessionsForUser(CallingContext context, string user);

     /**
     *  A type that is using a versioned repository will be able to use tags - these are fixed points in time 
         (that are invariant) that reflect what the repository looked like when the tag was created. 
         For example a tag could be assigned to a repository that marks the end of day view for a repository. 
         Any changes made after this tag was created will be accessible in the normal perspective but will not be associated with the tag. 
         This method returns all of the tags associated with this type in the given authority.
     * 
     */
     List<string> getTags(CallingContext context, string raptureURI);

     /**
     * This method removes a user from this Rapture system. The user is removed from all entitlement groups also. The actual
         user definition is retained and marked as inactive (so the user cannot login). This is because the user may still be 
         referenced in audit trails and the change history in type repositories.
     * 
     */
     void deleteUser(CallingContext context, string userName);

     /**
     * This method destroys a user record. The user must have been previously disabled using 'deleteUser' before this method 
         may be called. This is a severe method that should only be used in non-production machines or to correct an administrative
         error in creating an account with the wrong name before that account has been used. Reference to the missing user may still
         exist, and may not display properly in some UIs
     * 
     */
     void destroyUser(CallingContext context, string userName);

     /**
     * This method restores a user that has been deleted
     * 
     */
     void restoreUser(CallingContext context, string userName);

     /**
     * This method adds a user to the Rapture environment. The user will be in no entitlement groups by default. The password
         field passed is actually the MD5 hash of the password - or at least the same hash function that will be applied when
         logging in to the system (the password is hashed, and then hashed again with the salt returned during the login protocol).
     * 
     */
     void addUser(CallingContext context, string userName, string description, string hashPassword, string email);

     /**
     * This api call can be used to determine whether a given user exists in the Rapture system. Only system administrators can use this api call.
     * 
     */
     bool doesUserExist(CallingContext context, string userName);

     /**
     * Retrieve a single user given their name.
     * 
     */
     RaptureUser getUser(CallingContext context, string userName);

     /**
     *  Generates an api user, for use in connecting to Rapture in a relatively opaque way using a shared secret. An api user can log in with their access key without a password.
     * 
     */
     RaptureUser generateApiUser(CallingContext context, string prefix, string description);

     /**
     * This method gives an administrator the ability to reset the password of a user. The user will have the new password passed. The newHashPassword parameter should be an MD5 
         of the new password - internally this will be hashed further against a salt for this user.
     * 
     */
     void resetUserPassword(CallingContext context, string userName, string newHashPassword);

     /**
     * Creates password reset token
     * 
     */
     string createPasswordResetToken(CallingContext context, string username);

     /**
     * Cancels password reset token
     * 
     */
     void cancelPasswordResetToken(CallingContext context, string username);

     /**
     * This method updates user email.
     * 
     */
     void updateUserEmail(CallingContext context, string userName, string newEmail);

     /**
     * This method lists the remotes created on this system (the connections this system may make to other systems).
     * 
     */
     List<RaptureRemote> getRemotes(CallingContext context);

     /**
     * Remotes are used to connect one Rapture cloud environment to another. Each remote manages a connection to another Rapture cloud
         through the http api. This method adds a new remote to this system. 
         The apikey is the login name of a user on the remote cloud with adequate entitlements to push and pull the
         data to be synchronized or accessed via the remote. The description can be any text to help the human administrators tell clouds apart.
         The url is the http end point of the remote system.
     * 
     */
     RaptureRemote addRemote(CallingContext context, string name, string description, string url, string apiKey, string optP);

     /**
     * This method deletes a previously created remote.
     * 
     */
     void deleteRemote(CallingContext context, string name);

     /**
     * This method updates the user api key used by a given remote. This is an api key for the remote system, not this Rapture system.
     * 
     */
     void updateRemoteApiKey(CallingContext context, string name, string apiKey);

     /**
     * A remote has been defined it can be used to synchronize one repository with another. This method defines how one (local) repository is connected to a remote type. 
         The binding is made between the combination of a authority, repository and perspective from one system to another. The previously defines remote will hand the 
         synchronization work.
     * 
     */
     void setRemote(CallingContext context, string raptureURI, string remote, string remoteURI);

     /**
     * This method reverses a previously defined association between two repositories
     * 
     */
     void clearRemote(CallingContext context, string raptureURI);

     /**
     * If this type has a remote defined, use it to sync this repository with that of the other.
     * 
     */
     void pullRemote(CallingContext context, string raptureURI);

     /**
     * This function adds a template to the Rapture system. A template is a simple way of registering predefined configs that can be used to automatically generate configs for repositories, queues, and the like. 
        Templates use the popular StringTemplate library for merging values into a text template.
     * 
     */
     void addTemplate(CallingContext context, string name, string template, bool overwrite);

     /**
     * This method executes a template, replacing parts of the template with the passed parameters to create a new string.
     * 
     */
     string runTemplate(CallingContext context, string name, string parameters);

     /**
     * This method returns the definition of a template.
     * 
     */
     string getTemplate(CallingContext context, string name);

     /**
     * Copies the data from one DocumentRepo to another. The target repository is wiped out before hand if 'wipe' is set to true. The target must already exist when this method is called.
     * 
     */
     void copyDocumentRepo(CallingContext context, string srcAuthority, string targAuthority, bool wipe);

     /**
     * Use this method to add an IP address to a white list of allowed IP addresses that can log in to this Rapture environment. Once set only IP addresses in this ipAddress list can access Rapture. By default there are no whitelist IP addresses defined which actually means that all IP addresses are allowed.
     * 
     */
     void addIPToWhiteList(CallingContext context, string ipAddress);

     /**
     * Use this method to remove an IP address from a white list
     * 
     */
     void removeIPFromWhiteList(CallingContext context, string ipAddress);

     /**
     * Use this method to return the IP white list
     * 
     */
     List<string> getIPWhiteList(CallingContext context);

     /**
     * This method runs a batch script at the target site
     * 
     */
     string runBatchScript(CallingContext context, string script);

     /**
     * This method retrieves all of the registered users in the system
     * 
     */
     List<RaptureUser> getAllUsers(CallingContext context);

     /**
     * This method kicks off a process that will migrate a DocumentRepo to an alternate config. A temporary type will be created with the new config,
         the old type will be locked for modifications and then all of the documents in the existing type will be copied to the new type, with the metadata intact.
         Optionally a number of historical versions will be kept if the source repository (and target) support it. Once all of the data has been copied the config
         attached to each type will be swapped and the type released for access. The temporary type will then be dropped.
     * 
     */
     void initiateTypeConversion(CallingContext context, string raptureURI, string newConfig, int versionsToKeep);

     /**
     * Set the archive config for a type
     * 
     */
     void putArchiveConfig(CallingContext context, string raptureURI, TypeArchiveConfig config);

     /**
     * Retrieve the archive config for a authority
     * 
     */
     TypeArchiveConfig getArchiveConfig(CallingContext context, string raptureURI);

     /**
     * Delete the archive config for a authority
     * 
     */
     void deleteArchiveConfig(CallingContext context, string raptureURI);

     /**
     * A general purpose function that tests (or refreshes) the api connection to Rapture with no side effects.
     * 
     */
     bool ping(CallingContext context);

     /**
     * This function adds values to the metadata field of the CallingContext. It's used to hold values specific to this connection. 
        Since it's set by the caller the values cannot be considered entirely trusted, and private or secure data such as passwords shouldn't be stored in here.
        If overwrite is false and an entry already exists then an exception should be thrown
     * 
     */
     void addMetadata(CallingContext context, Dictionary<string, string> values, bool overwrite);

     /**
     * Set the MOTD (message of the day) for this environment. Setting to a zero length string implies that there is no message of the day
     * 
     */
     void setMOTD(CallingContext context, string message);

     /**
     * Retrieve the MOTD
     * 
     */
     string getMOTD(CallingContext context);

     /**
     * Set the name of this environment
     * 
     */
     void setEnvironmentName(CallingContext context, string name);

     /**
     * Set the properties of this environment. Usually for displaying then name (e.g. BANNER_COLOR)
     * 
     */
     void setEnvironmentProperties(CallingContext context, Dictionary<string, string> properties);

     /**
     * Get the name of this environment
     * 
     */
     string getEnvironmentName(CallingContext context);

     /**
     * Get the properties of this environment
     * 
     */
     Dictionary<string, string> getEnvironmentProperties(CallingContext context);

     /**
     * Encode a String using the default encoding mechanism
     * 
     */
     string encode(CallingContext context, string toEncode);

     /**
     * Create a URI with proper encoding given a path and a leaf. Normal URI characters such as : or / in the path will not be encoded
     * 
     */
     string createURI(CallingContext context, string path, string leaf);

     /**
     * Create a URI with proper encoding given a list of elements. The return value will begin with // Each element will be encoded 
        (including all punctuation characters) and the elements joined together separated by /
     * 
     */
     string createMultipartURI(CallingContext context, List<string> elements);

     /**
     * Decode the supplied String according to the URI encoding/decoding rules
     * 
     */
     string decode(CallingContext context, string encoded);

     /**
     * Find the groups for a given user and return just the names
     * 
     */
     List<string> findGroupNamesByUser(CallingContext context, string username);

	}
}

