/**
 * Copyright (C) 2011-2015 Incapture Technologies LLC
 *
 * This is an autogenerated license statement. When copyright notices appear below
 * this one that copyright supercedes this statement.
 *
 * Unless required by applicable law or agreed to in writing, software is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * Unless explicit permission obtained in writing this software cannot be distributed.
 */
package rapture.kernel.plugin;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.fail;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import rapture.common.api.JarApi;
import rapture.common.exception.RaptureException;
import rapture.kernel.ContextFactory;
import rapture.kernel.Kernel;
import javax.tools.DiagnosticCollector;
import javax.tools.JavaCompiler;
import javax.tools.JavaFileObject;
import javax.tools.StandardJavaFileManager;
import javax.tools.StandardLocation;
import javax.tools.ToolProvider;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.jar.Attributes;
import java.util.jar.JarEntry;
import java.util.jar.JarOutputStream;
import java.util.jar.Manifest;

/**
 * Created by zanniealvarez on 10/13/15.
 */
public class RapturePluginClassLoaderIntegrationTest {
    private static String newline = System.getProperty("line.separator");

    private static String fakePackage1 = "rapture1.test.fake";
    private static String jarFileName1 = "simple-beans.jar";

    private static String fakePackage2 = "rapture2.test.fake";
    private static String jarFileName2 = "composite-bean.jar";

    private static RapturePluginClassLoader classLoader;
    private static JarApi jarApi = null;

    @Rule
    public TemporaryFolder tmpFolder = new TemporaryFolder();

    @BeforeClass
    public static void setup() {
        classLoader = new RapturePluginClassLoader();
        Thread t = Thread.currentThread();
        t.setContextClassLoader(classLoader);

        try {
            Kernel.initBootstrap(null, null, true);
            jarApi = Kernel.getJar();
        } catch (RaptureException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testLoadJavaClass() {
        testFindableClass("java.lang.String");
    }

    @Test
    public void testLoadRaptureClass() {
        testFindableClass("rapture.common.RaptureFolderInfo");
    }

    @Test
    public void testLoadNonexistentClass() {
        testUnfindableClass("some.crap.that.doesnt.Exist");
    }

    @Test
    public void testLoadJarApiClass() {
        Set<String> classNames = loadJarsIntoRaptureAndGetClassNames();
        assertFalse(classNames.isEmpty());

        // We shouldn't be able to find these classes until the jars have been enabled
        for (String className: classNames) {
            testUnfindableClass(className);
        }

        jarApi.enableJar(ContextFactory.getKernelUser(), "jar://" + jarFileName1);
        jarApi.enableJar(ContextFactory.getKernelUser(), "jar://" + jarFileName2);

        for (String className: classNames) {
            testFindableClass(className);
        }

        jarApi.deleteJar(ContextFactory.getKernelUser(), "jar://" + jarFileName1);
        jarApi.deleteJar(ContextFactory.getKernelUser(), "jar://" + jarFileName2);
    }

    private void testFindableClass(String className) {
        try {
            Class klass = classLoader.loadClass(className);
            assertEquals(className, klass.getName());

            Object xyz = klass.newInstance();
        }
        catch (ClassNotFoundException e) {
            fail("Should have been able to find class " + className);
        }
        catch (InstantiationException|IllegalAccessException e) {
            fail("Could not instantiate " + className);
        }
    }

    private void testUnfindableClass(String className) {
        try {
            classLoader.loadClass(className);
            fail("Should not have been able to find class " + className);
        }
        catch (ClassNotFoundException e) {
        }
    }

    private Set<String> loadJarsIntoRaptureAndGetClassNames() {
        Set<String> classNames = new HashSet();
        HashSet<File> javaFiles = new HashSet();

        try {
            tmpFolder.create();
            makeSimpleBean("BostonBean", classNames, javaFiles);
            makeSimpleBean("SoyBean", classNames, javaFiles);
            makeSimpleBean("GreenBean", classNames, javaFiles);

            // make one that we don't explicitly list in classNames, to be referenced in a composite bean
            String simpleBeanName = "CabbageAndGreens";
            String compositeBeanName = "JavaJive";
            writeJavaFile(simpleBeanName + ".java", getSimpleBeanCode(simpleBeanName), javaFiles);
            writeJavaFile(compositeBeanName + ".java", getCompositeBeanCode(compositeBeanName, simpleBeanName), javaFiles);
            classNames.add(fakePackage2 + "." + compositeBeanName);

            if (!compileJavaFiles(javaFiles)) {
                fail("Failed to compile Java files");
            }

            makeJar("rapture1", jarFileName1);
            makeJar("rapture2", jarFileName2);
        }
        catch (IOException e) {
            fail("Got IOException when attempting to create sample jars.");
        }

        return classNames;
    }

    private void makeJar(String topLevel, String jarName) {
        try {
            File topDir = null;
            for (File file : tmpFolder.getRoot().listFiles()) {
                if (file.getName().equals(topLevel)) {
                    topDir = file;
                    break;
                }
            }

            if (topDir == null) {
                fail("Top package directory " + topLevel + " not found");
            }

            String jarFilePath = tmpFolder.getRoot().getAbsolutePath() + System.getProperty("file.separator") + jarName;
            jarClassFiles(topDir, jarFilePath);

            byte[] jarBytes = Files.readAllBytes(Paths.get(jarFilePath));
            String jarUri = "jar://" + jarName;
            jarApi.putJar(ContextFactory.getKernelUser(), jarUri, jarBytes);
        }
        catch (IOException e) {
            fail("Got IOException when attempting to create sample jar " + jarName);
        }
    }

    private void makeSimpleBean(String simpleBeanName, Set<String> classNames, Set<File> javaFiles) throws IOException {
        writeJavaFile(simpleBeanName + ".java", getSimpleBeanCode(simpleBeanName), javaFiles);
        classNames.add(fakePackage1 + "." + simpleBeanName);
    }

    private void writeJavaFile(String fileName, String code, Set<File> javaFiles) throws IOException {
        File simpleBeanFile = tmpFolder.newFile(fileName);
        FileWriter writer = new FileWriter(simpleBeanFile);
        writer.write(code);
        writer.close();

        javaFiles.add(simpleBeanFile);
    }

    private Boolean compileJavaFiles(HashSet<File> javaFiles) throws IOException {
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<>();

        StandardJavaFileManager fileManager = compiler.getStandardFileManager(diagnostics, null, null);
        // Setting the location results in creating the directory structure of the package, instead
        // of putting the .class files directly in the tmpFolder.
        fileManager.setLocation(StandardLocation.CLASS_OUTPUT, Arrays.asList(tmpFolder.getRoot()));

        Iterable<? extends JavaFileObject> compilationUnits = fileManager.getJavaFileObjectsFromFiles(javaFiles);

        JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, diagnostics, null, null, compilationUnits);
        boolean success = task.call();
        fileManager.close();

        return success;
    }

    private void jarClassFiles(File topPackageDirectory, String jarFilePath) throws IOException {
        Manifest manifest = new Manifest();
        manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");

        JarOutputStream target = new JarOutputStream(new FileOutputStream(jarFilePath), manifest);
        addToJar(topPackageDirectory, target);
        target.close();
    }

    private void addToJar(File source, JarOutputStream target) throws IOException
    {
        BufferedInputStream in = null;
        try
        {
            if (source.isDirectory()) {
                String name = getJarEntryPath(source);
                if (!name.isEmpty()) {
                    if (!name.endsWith("/")) {
                        name += "/";
                    }

                    JarEntry entry = new JarEntry(name);
                    entry.setTime(source.lastModified());
                    target.putNextEntry(entry);
                    target.closeEntry();
                }

                for (File nestedFile : source.listFiles()) {
                    addToJar(nestedFile, target);
                }

                return;
            }

            JarEntry entry = new JarEntry(getJarEntryPath(source));
            entry.setTime(source.lastModified());
            entry.setSize(source.length());
            target.putNextEntry(entry);
            in = new BufferedInputStream(new FileInputStream(source));

            byte[] buffer = new byte[1024];
            while (true)
            {
                int count = in.read(buffer);
                if (count == -1)
                    break;
                target.write(buffer, 0, count);
            }
            target.closeEntry();
        }
        finally
        {
            if (in != null)
                in.close();
        }
    }

    private String getJarEntryPath(File file) throws IOException {
        return file.getCanonicalPath()
                .substring(tmpFolder.getRoot().getCanonicalPath().length() + 1, file.getCanonicalPath().length())
                .replace("\\", "/");
    }

    private String getSimpleBeanCode(String className) {
        return
            "package " + fakePackage1 + ";" + newline +
            "public class " + className + " {" + newline +
            "   String type;" + newline +
            "   public String getType() { return type; }" + newline +
            "   public void setType(String type) { this.type = type; }" + newline +
            "}" + newline;
    }

    private String getCompositeBeanCode(String className, String memberClass) {
        return
            "package " + fakePackage2 + ";" + newline +
            "import " + fakePackage1 + "." + memberClass + ";" + newline +
            "public class " + className + " {" + newline +
            "   " + memberClass + " food;" + newline +
            "   public " + className + "() { food = new " + memberClass + "(); }" + newline +
            "   public " + memberClass + " getFood() { return food; }" + newline +
            "   public void setFood(" + memberClass + " food) { this.food = food; }" + newline +
            "}" + newline;
    }
}
