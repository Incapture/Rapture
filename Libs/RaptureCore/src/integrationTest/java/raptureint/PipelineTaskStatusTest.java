/**
 * Copyright (C) 2011-2015 Incapture Technologies LLC
 *
 * This is an autogenerated license statement. When copyright notices appear below
 * this one that copyright supercedes this statement.
 *
 * Unless required by applicable law or agreed to in writing, software is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * Unless explicit permission obtained in writing this software cannot be distributed.
 */
package raptureint;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.junit.Before;
import org.junit.Test;

import rapture.common.CallingContext;
import rapture.common.PipelineTaskState;
import rapture.common.PipelineTaskStatus;
import rapture.common.RapturePipelineTask;
import rapture.common.TableQuery;
import rapture.common.TableSelect;
import rapture.common.exception.RaptureException;
import rapture.common.model.RaptureExchange;
import rapture.common.model.RaptureExchangeQueue;
import rapture.common.model.RaptureExchangeType;
import rapture.kernel.ContextFactory;
import rapture.kernel.Kernel;
import rapture.util.NetworkUtil;
import rapture.config.ConfigLoader;

@SuppressWarnings("all")
public class PipelineTaskStatusTest {

    private CallingContext ctx;

    @Before
    public void setup() {
        ctx = ContextFactory.getKernelUser();

        try {
            Kernel.initBootstrap(null, null, true);

            Kernel.getPipeline().getTrusted().registerServerCategory(ctx, "alpha", "Primary servers");
            Kernel.getPipeline().getTrusted().registerServerCategory(ctx, "beta", "Secondary servers");

            Kernel.getPipeline().registerExchangeDomain(ctx, "main", "EXCHANGE {} USING MEMORY {}");

            RaptureExchange exchange = new RaptureExchange();
            exchange.setName("kernel");
            exchange.setExchangeType(RaptureExchangeType.FANOUT);
            exchange.setDomain("main");

            List<RaptureExchangeQueue> queues = new ArrayList<RaptureExchangeQueue>();
            RaptureExchangeQueue queue = new RaptureExchangeQueue();
            queue.setName("default");
            queue.setRouteBindings(new ArrayList<String>());
            queues.add(queue);

            exchange.setQueueBindings(queues);

            Kernel.getPipeline().getTrusted().registerPipelineExchange(ctx, "kernel", exchange);
            Kernel.getPipeline().getTrusted().bindPipeline(ctx, "alpha", "kernel", "default");

            // Now that the binding is setup, register our server as being part
            // of
            // "alpha"

            Kernel.setCategoryMembership("alpha");

        } catch (RaptureException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testPipelineStatus() {

        ConfigLoader.getConf().DefaultPipelineTaskStatus = "INDEX {} USING MONGODB { prefix = \"pipelineTaskStatus\" }";
        RapturePipelineTask pTask = new RapturePipelineTask();
        pTask.setContent("Testing out the pipeline status");
        pTask.setContentType("text/plain");
        pTask.setPriority(1);
        pTask.setCategoryList(new ArrayList<String>());

        Kernel.getPipeline().getTrusted().publishPipelineMessage(ctx, "kernel", pTask);

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        PipelineTaskStatus status = Kernel.getPipeline().getStatus(ctx, pTask.getTaskId());
        if (status == null) {
            return;
        }
        Map<PipelineTaskState, String> states = status.getStates();
        if (states.containsKey(PipelineTaskState.COMPLETED)) {
            assertEquals(NetworkUtil.getServerName(), states.get(PipelineTaskState.COMPLETED));
            assertEquals(NetworkUtil.getServerName(), states.get(PipelineTaskState.RUNNING));
            assertEquals(NetworkUtil.getServerName(), states.get(PipelineTaskState.SUBMITTED));
        }

        TableQuery query = new TableQuery();
        TableSelect sel = new TableSelect();
        sel.setFieldName("status.states.COMPLETED");
        sel.setOper("LIKE");
        sel.setTestValue(".*");
        List<TableSelect> sels = new ArrayList<TableSelect>();
        sels.add(sel);
        query.setFieldTests(sels);
        List<RapturePipelineTask> rpts = Kernel.getPipeline().queryTasksOld(ctx, query);
        if (rpts == null) return;
        for (RapturePipelineTask rp : rpts) {
            System.out.println(rp.getStatus().getTaskId());
            System.out.println(rp.getStatus().getCurrentState().toString());
        }
        System.out.println(rpts.size());

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testEpoch() {
        long x = 6L;
        TableQuery query = new TableQuery();
        TableSelect sel = new TableSelect();
        sel.setFieldName("epoch");
        sel.setOper(">");
        sel.setTestValue(x);
        List<TableSelect> sels = new ArrayList<TableSelect>();
        sels.add(sel);
        query.setFieldTests(sels);
        List<RapturePipelineTask> rpts = Kernel.getPipeline().queryTasksOld(ctx, query);
        if (rpts == null) return;
        for (RapturePipelineTask rp : rpts) {
            System.out.println(rp.getStatus().getTaskId());
            System.out.println(rp.getStatus().getCurrentState().toString());
        }
        System.out.println(rpts.size());
    }

}
