
\part{Reflex}
\chapter{Background}
Recently there has been a significant move to create languages that run on top of the Java Virtual Machine. These languages are usually integrated as a fundamental "Java Scripting Language" - such as JRuby \index{JRuby} (an implementation of Ruby \index{Ruby}), Jython \index{Jython} (the equivalent of Python \index{Python}) and Rhino \index{Rhino} (a JavaScript \index{JavaScript} implementation) or as a fully defined language that hooks into the JVM at a lower level. Examples of these languages would include Clojure \index{Clojure} (a functional Lisp dialect), Groovy \index{Groovy} (a scripting language) and Scala \index{Scala} (an object-oriented and functional programming language).

\Reflex is a procedural language that hooks into the JVM at a lower level. Its syntax is similar to Python (without the indentation) and there are a number of built-in functions and special operators that are semantic short cuts when interacting with \Rapture.

This part of the document provides a detailed description of \Reflex.

\section{Why Reflex?}
The designers of \Rapture felt that it was very important to provide a non-compiled way of running programs "in the cloud"\index{cloud}. The idea was that \Rapture application developers could define a lot of their data manipulations in a scripting language and then have \Rapture run these "programs" on the servers that make up an installed system. If such a program could be agnostic to the machine (actual server) it was running on such manipulations could be run in a scalable way across all of the servers that make up a \Rapture system.

Initially the support for such a scripting language was built using JRuby and Jython - two well established languages that have a well educated developer base. Unfortunately this support ended up being impractical - both from a licensing perspective and from the fact that the scripting environment for these languages was very resource (time and memory) intensive. For these reasons it was decided to create a small language (now called \Reflex) to provide the "glue" for the data interactions in \Rapture.

\chapter{Server hosted scripting}
The initial use for \Reflex was to provide a scripting language that could be run on a server. However the same language could also be used to help setup a \Rapture system and hooks were also built in to handle file based io - something that normally would be restricted on a cloud/distributed server environment. In fact a \Reflex environment now has a number of "hooks" that can be implemented (or wired) differently depending on the context. In general the environment looks like the logical diagram below.

\begin{figure}[H]
\centering
\begin{tikzpicture}
\node[external](Reflex) { \Reflex     };
\node[api] (File) [below right=of Reflex] { File IO }
   edge [post, bend right=45] (Reflex);
\node[client] (Plugin) [right=of Reflex] { Plugins}
   edge [post] (Reflex);
\node[api] (API) [below left=of Reflex] { \Rapture }
   edge [post,bend left=45]  (Reflex);
\node[api] (Scripting) [below=of Reflex] { Scripting }
   edge [post] (Reflex);
\node[api](Debugger) [above left=of Reflex] { Debugger }
   edge [post, bend left=45] (Reflex);
\end{tikzpicture}
\caption { Logical Reflex environment }
\end{figure}

Here we see that \Reflex can reach out to a debugger, a \Rapture environment (for calling its API), a Scripting environment (for loading other scripts) and an IO sub-system for loading and saving data to a file system.

When running within a \Rapture server, the implementations are frozen to protect the environment:

\begin{figure}[H]
\centering
\begin{tikzpicture}
\node[external](Reflex) { \Reflex     };
\node[internal] (File) [below right=of Reflex] { Disabled }
   edge [post, bend right=45] (Reflex);
\node[client] (Plugin) [right=of Reflex] { Plugins}
   edge [post] (Reflex);
\node[api] (API) [below left=of Reflex] { \Rapture }
   edge [post,bend left=45]  (Reflex);
\node[api] (Scripting) [below=of Reflex] { Scripting }
   edge [post] (Reflex);
\node[internal](Debugger) [above left=of Reflex] { Disabled }
   edge [post, bend left=45] (Reflex);
\end{tikzpicture}
\caption { Server Reflex environment }
\end{figure}

Here the debugger and the file/IO subsystems are disabled.

\Reflex can also be run on a local desktop, or on a server outside of a \Rapture environment. In this case the bindings of the environment are as below:
\begin{figure}[H]
\centering
\begin{tikzpicture}
\node[external](Reflex) { \Reflex     };
\node[api] (File) [below right=of Reflex] { File }
   edge [post, bend right=45] (Reflex);
\node[client] (Plugin) [right=of Reflex] { Plugins}
   edge [post] (Reflex);
\node[api] (API) [below left=of Reflex] { \Rapture }
   edge [post,bend left=45]  (Reflex);
\node[api] (Scripting) [below=of Reflex] { Scripting }
   edge [post] (Reflex);
\node[api](Debugger) [above left=of Reflex] { Debugger }
   edge [post, bend left=45] (Reflex);
\node[external](HTTP) [below left=of API] { HTTP }
   edge [post] (API)
   edge [post] (Scripting);
\node[ewd](Remote) [below=of HTTP] { Remote\nodepart{second}\Rapture }
   edge [post] (HTTP);
\end{tikzpicture}
\caption { External Reflex environment }
\end{figure}

In this case the environment has a \Rapture system wired in via a standard HTTP based API - all \Rapture commands in \Reflex will still work through that API. In a server based environment the security context is set by \Rapture (and is based on the ultimate initiator of the \Reflex process). In the external approach the user security context is set either by using a \Rapture "API key" or by logging in manually through the Reflex runner application.

\chapter{Running Reflex}
There are three options for using \Reflex. The most common use for \Reflex is to run scripts from within a \Rapture environment - you upload scripts to \Rapture and then call them through either \Rapture's API call \Verb+runScript+ or through a \Rapture workflow or event handling.

For testing and debugging it is preferable to install a local environment to play with. This section describes how to do that.

\Reflex is bundled into an application called \emph{ReflexRunner} that can be used to run \Reflex scripts. ReflexRunner is a command line java application that can be downloaded from the \href{http://incapture.github.com/RaptureRepo/release}{\Rapture Release Site}. Once downloaded it can be run using java as follows:

\begin{Verbatim}[fontsize=\small]
  java -jar ReflexRunner [options]

  ReflexRunner [-r Rapture API URL]
               [-u Rapture username]
               [-p Rapture password]
               [-f Script file]
               [-params Script parameters]
               [-d Debug]
               [-i Instrument]
\end{Verbatim}

\subsection{Examples}

Execute a script with a parameter:
\begin{Verbatim}
ReflexRunner -r http://localhost:8665/rapture
             -f myScript.rfx -param x=1
\end{Verbatim}
Execute a script with 2 parameters:
\begin{Verbatim}
ReflexRunner -r http://localhost:8665/rapture
             -f myScript.rfx -param x=1,y=abc
\end{Verbatim}
Execute a script with instrumentation:
\begin{Verbatim}
ReflexRunner -r http://localhost:8665/rapture
             -f myScript.rfx -i
\end{Verbatim}

\subsection{Usage notes}
\begin{itemize}
\item{-r and -f are mandatory parameters}
\item{User name and password will be prompted for if not set using switches or environment variables.}
\item{Cannot use -i and -d switches at the same time}
\item{Parameter input format is a comma seperated list of: <variable name>=<variable value}
\end{itemize}

\subsection{Supported environment variables}
\begin{itemize}
\item{RAPTURE\_HOST sets -r}
\item{RAPTURE\_USER sets -u}
\item{RAPTURE\_PASSWORD sets -p}
\end{itemize}

\subsection{Exit codes}
\begin{itemize}
\item{0: No parameters passed.}
\item{1: Rapture URL (-r) parameter or environment variable is missing.}
\item{2: Switches -d and -i cannot be used at same time.}
\end{itemize}

\chapter{Reflex fundamentals}
\Reflex is a basic procedural language with a few special operators \index{operator} and built-in functions \index{function} to make \Rapture interactions quicker to write. In this case the meaning of "procedural" is simply that in \Reflex you can define functions and invoke those functions. This section describes the fundamental characteristics of the language.
\section{Hello, World}
The simplest program in \Reflex uses the built-in function \Verb+println+ \index{println} to print out the contents to standard out:
\begin{lstlisting}[caption={Hello world}]
// This is Hello World in Reflex
println('Hello, world');

\end{lstlisting}

Running the above program in Eclipse or through the ReflexRunner will print out the string 'Hello, world' on the console. It introduces two concepts. Line 1 shows how comments are defined in \Reflex. Comments are prefixed with a double slash and continue to the end of the line. This is the only comment style in \Reflex. Line 2 shows the built-in function \Verb+println+ and the fact that strings can be enclosed either in single quotes or double quotes. Finally statements in \Reflex are terminated by semi-colons.

\section{Variables and Types}

Variables \index{variable} in \Reflex are created upon first declaration and can be named using the letters of the alphabet and the digits 0 - 9. Some examples of variable names are shown in the table below:

\begin{table}[h]
\small
\centering
\begin{tabular} { | l | l | }
Variable Name & Valid? \\
\hline
abc & Yes \\
aB0 & Yes \\
a*3 & No (contains a *) \\
reflex & Yes \\
\_var & No (contains a \_) \\
\end{tabular}
\caption{Variable names in \Reflex}
\end{table}

Types \index{type} in \Reflex are inferred from the context in which a value is assigned, and wherever possible a type will be coerced into another if the other type is needed for a context. The types are listed in table \vref{tab:Types}.

\begin{table}[h!]
\small
\centering
\begin{tabular} { | c | c | p{5cm} | }
\hline
Type & Example & Description \\
\hline
string & 'Hello' & A string, an array of characters \\
number & 4.0 & A number, either an integer or a float, depending on context \\
integer & 4 & A specific integer (not the general number) \\
boolean & true & A boolean value, either true or false \\
list & \Verb+[ 1, 2, 3]+ & A list of values \\
map & \Verb+{ 'key' : 'value' }+ & An associate map, mapping keys (strings) to values. \\
date & \Verb+ date() + & A date. \\
time & \Verb+ time() + & A time. \\
file & \Verb+ file('test.txt') + & A file object, used to read or write data. \\
nul & \Verb+ null + & An object representing a nul value.\\
void & \Verb+ void + & An object representing "no" object.\\
lib & \Verb+ lib(className) + & An object representing a \Reflex library. \\
stream & \Verb+ x = file('test.txt', 'CSV');+ & An object representing a stream of data from a file. \\
process & \Verb+ p = spawn('ls');+ & An object representing an external process. \\
timer & \Verb+ t = timer();+ & An object representing a timer that is started on creation. \\
\hline
\end{tabular}
\label{tab:Types}
\caption{Types in \Reflex}
\end{table}

The more complex types (stream, file) will be introduced in a later section on integration with \Rapture.

\section{Type conversion}
\Reflex will attempt to convert \index{conversion} from one type to another as needed. The table below shows what conversions are implicit and which ones need a little help from a built in function.

\begin{table}[h!]
  \small
\centering
\begin{tabular} { | c | c | c | c | c | c | c | c |}
\hline
       & \multicolumn{7}{c|} {From} \\ \hline
To     & String & Number & Boolean & List & Map & Date & Time\\
\hline
String &        &  auto  &  auto   & auto & auto & auto & auto\\
Number &  cast  &        &  n/a    &  n/a & n/a & Julian & Millis\\
Boolean&  n/a   &  n/a   &         & n/a  & n/a & n/a & n/a \\
List   &  n/a   &  n/a   &  n/a    &      & n/a & n/a & n/a \\
Map    &  n/a   &  n/a   &  n/a    & n/a  & n/a & n/a & n/a  \\
Date   &  yyyyMMdd & Julian  & n/a & n/a & n/a & & n/a \\
Time   &  HH:MM:SS & Millis & n/a & n/a & n/a & n/a & \\
\hline
\end{tabular}
\caption{Conversions in \Reflex}
\end{table}

\section{Initialization}
\index{initialize}\Reflex types are determined by context - for example the result of calling the built-in \Verb+size+ function is a number, so assigning a variable to the result of calling that function will result in a numeric variable being created. Another way of defining the type of a variable is to initialize it. Reflex uses the format of the initialization to determine the type.

A variable initialization can also be prefixed with the keyword \Verb+const+\index{const}. This keyword ensures that the value of this variable will be unchanged after first assignment, and that the variable will be accessible globally, including within functions.

\subsection{String}
The string type is initialized through a statement enclosed in either single quotes or double quotes. The different quoting options are equivalent in \Reflex - the choice is a matter of convenience. If your string needs to contain double quotes you can enclose it in single quotes and vice versa.\index{quote}
\begin{lstlisting}[caption={String initialization}]
// String initialization
a = 'a string';
b = 'another string';
c = "A string in quotes";
const d = "There's a string in here somewhere";
\end{lstlisting}

When a string is wrapped in double quotes \Reflex will attempt to substitute variable names embedded in the string with their values. A variable
name used in this way is prefixed with \Verb+\${+ and closed with \Verb+}+.

\begin{lstlisting}[caption={String interpretation}]
// String initialization
value = 5;
println("The value is ${value}");
// Prints out 'The value is 5'
\end{lstlisting}

Strings in single quotes are not expanded.

\subsection{Number}
The number \index{number} type is initialized through a statement that represents a number - either an integer (a series of digits) or a floating point number through either a series of digits, a decimal point and a further series of digits, or through the definition of a number through scientific notation. If you suffix a number representation with a capital L the number will be locked to an internal integer \index{integer} type, which is useful when using these numbers in native Java calls.
\begin{lstlisting}[caption={Number initialization}]
// Number initializaion
a = 10;
b = 100.4;
const c = 5L;
d = 4.5E04; // equivalent to 45000
\end{lstlisting}

If a number can be represented as an integer it will be stored as an integer initially.

\subsection{Boolean}
The boolean \index{boolean} type is defined using the keywords \Verb+true+ and \verb+false+, and of course can be initialized through the use of a boolean statement (see boolean operators in a later section).
\begin{lstlisting}[caption={Boolean initialization}]
// Boolean initialization
a = true;
const b = false;
c = (1 == 1); // c == true
\end{lstlisting}
\subsection{List}
The list \index{list} type is defined using square brackets, with elements of the list being separated by commas. The elements can be any expression which includes the name of an existing (pre-defined) variable.
\begin{lstlisting}[caption={List initialization}]
// List initialization
a = []; // An empty list
const b = [1, 2, 3, 4, 5];
c = ['A string', 1, []]; // A list of a string, a number, and an empty list
\end{lstlisting}
\subsection{Map}
A map \index{map} is initialized using a JSON style format and is best demonstrated through example.
\begin{lstlisting}[caption={Map initialization}]
// Map initialization
a = {}; // An empty map
b = { 'a' : 4 }; // A map containing a
                 // single entry, with
                 // the key 'a' and the value 4
c = { 'one' : 1, 'two' : 2, 'three' : 3 };
const d = { 'outer' : { 'inner' : true }};
\end{lstlisting}
\subsection{Date}
A date \index{date} is initialized using the built-in \Verb+date+ function. When no arguments are provided the date is
initialized to the current date as understood by the server the script is running on.

When more than one argument is specified the first argument specifies a date in \Verb+yyyyMMdd+ format, and if a second
argument is provided it is used to determine how arithmetic can be performed on this date object. It can be one of those listed below:

\begin{table}[h!]
\small
\centering
\begin{tabular} { | c | p{7cm} | }
\hline
Calendar & Description \\
\hline
BDF & The date will always fall on the days Monday-Friday. \\
BDFAct & When moving the date by an amount, weekends count as zero days. The date will always fall on a weekday. \\
\hline
\end{tabular}
\label{tab:DateCalendarTypes}
\caption{Calendar Types in \Reflex}
\end{table}

\begin{lstlisting}[caption={Date examples}]
d1 = date();
d2 = date('20160101');
d3 = date('20160101', 'BDFAct');
\end{lstlisting}


\section{Simple examples}
Based on our understanding of types and variables, and our simple \Verb+println+ function, we can create some new \Reflex scripts. Here is a longer script that creates some variables and introduces some of the operators that will be expanded upon in the next section.

\begin{lstlisting}[caption={Variables and Types}]

// An example Reflex script showing variables and types
x = 10;
y = "Hello";
z = x + 1;
println("Z is " + z);
\end{lstlisting}

In this example we have defined three variables, $x$, $y$ and $z$. $x$ and $z$ are ultimately numbers and $y$ is a string. We create the variable $x$ on line 3, and $y$ on line 4. $z$ is implicitly created as the value of $x+1$ (i.e. 11). Finally we print out the value of $z$ on line 6, but note that we have used the $+$ operator on a string (\Verb+Z is+) and a number (the variable $z$). In this case \Reflex will convert $z$ from a number to a string and then append the strings together.

\chapter{Operators}
Operators \index{operator} in \Reflex will, in the most part, be very familiar to developers of other languages. There are boolean \index{boolean} operators ($==$, $>=$, $<=$, $<$, $>$, $!=$, $||$, $\&\&$), arithmetic \index{arithmetic} operators ($+$,$-$,$/$,$*$,$\%$) and index \index{index} operators (\Verb+[ ]+). The ternary \index{ternary} operator $?$ is also supported. The use of these \emph{simple} operators is best illustrated by example. The examples below also introduce the \verb+assert+ built-in function - it aborts the \Reflex script with an error if the result of the boolean expression is \verb+false+.
\begin{lstlisting}[caption={Simple operators}]
// Examples of use of simple operators
// Boolean operators
assert(true);
assert(true || false);
assert(!false);
assert(true && true);
// Relational
assert(1 < 2);
assert(55 >= 55);
assert('a' < 'b'); // Note that strings can be compared
// Addition
assert(1 + 999 == 1000);
assert([1] + 1 == [1,1]); // Note addition on lists
assert([1,2,3] - 3 == [1,2]); // Note subtraction on lists
// Multiply
assert(3 * 50 == 150);
assert(4 / 2 == 2);
assert(999 % 3 == 0); // % = mod operator
// Power
assert(2 ^ 3 == 8);
\end{lstlisting}
It is worth calling out explicitly how $+$ and $-$ work with lists. If the left hand side of an expression is a list, then adding an element to it results in a new list with that element added to the end. Subtracting from a list removes that element from the list if it is within the list. This also works with strings.

The index \Verb+[ ]+ operator is worth its own set of examples.
\begin{lstlisting}[caption={Index operator}]
// Examples of the index operator
a = [1, 2, 3, 4, 5];
b = 'abcdefg';
assert(a[0] == 1);
assert(a[1 .. 2] == [2,3]);
assert(b[0] == 'a');
assert(b[1 .. 2] == 'bc');
\end{lstlisting}
There are two forms of the index operator. The first, with one integer parameter, simply returns the element at that position. The second, with the \Verb+..+ directive is a range operator - it returns the elements between these index points, inclusive of the first parameter and exclusive of the second.

The index operator also applies to map types as well. In this case the parameter is a string and refers to the key to lookup in the associative map.
\begin{lstlisting}[caption={Index operator on maps}]
a = { 'one' : 1, 'two' : 2 };
assert(a['one'] == 1);
assert(a['two'] == 2);
\end{lstlisting}

The dot operator ($.$) can be used with maps to reference elements of that map:

\begin{lstlisting}[caption={Dot operator on maps}]
a = { 'one' : 1, 'two' : 2 };
assert(a.one == 1);
assert(a.two == 2);
a.three = 3;
assert(a.three == 3);
\end{lstlisting}

\chapter{Flow control}
\Reflex has the standard flow control statements such as \Verb+ if ... else +, \verb+ while +, \verb+ for loops+.
\section{If}
The \Reflex \Verb+if+ \index{if} statement has the following form:
\begin{Verbatim}
if booleanExpression do
   block
else do
   block
end
\end{Verbatim}
For statements without an else \index{else} block the complete \Verb+ else do block+ can be omitted.

\begin{lstlisting}[caption={If statement}]
// An If statement
a = 4;
b = 2;
if a > 3 do
   println("A is greater than 3");
else do
   println("A is less than or equal to 3");
end

if b == 2 do
   println("Yes, b is 2");
end
\end{lstlisting}
Note that there does not need to be a semi-colon after the \Verb+end+ keyword here.
\section{While}
The \Reflex \Verb+while+\index{while} statement has the following form:
\begin{Verbatim}
while booleanExpression do
    block
end
\end{Verbatim}

\begin{lstlisting}[caption={While statement}]
// A while loop
a = true;
b = 0;
while a do
   b = b + 1;
   if b > 5 do
      a = false;
   end
end
\end{lstlisting}
\section{For}
\Reflex has two different \Verb+for+\index{for} loop forms. The first, the counting form, assigns a numeric variable the values from a starting number to an ending number (inclusive) and calls the inner block for each iteration.
\begin{lstlisting}[caption={For counting form}]
// A for loop
for a = 0 to 10 do
   println("The value of a is " + a);
end
\end{lstlisting}
The second is known as the iterator \index{iterator} form, and it takes as a secondary argument a list expression (which can be a variable or an expression that yields a list). The value of the variable is set to each element in the list and the inner block is called with that element set.
\begin{lstlisting}[caption={For iterator form}]
// A for loop
a = [1, 2, 3, 4 ];
b = [];
for c in a do
   b = b + ( c * 2 );
end
assert(c == [2, 4, 6, 8 ];
\end{lstlisting}
\section{PFor}
\Reflex also has a novel way of running \Verb+for+ blocks in parallel, through the \verb+pfor+ keyword. \verb+Pfor+ can replace \verb+for+ in most cases and \Reflex will attempt to run the loop in parallel, with each statement being executed on a pool of threads. Care must be taken with this approach as sequencing of changes can occur out of a natural order. Both the counting and iterator form are supported.
\begin{lstlisting}[caption={PFor counting form}]
// A pfor loop

res = {};
pfor a = 0 to 10 do
   res['' + a] = a;
end

println("The resultant map is " + res);
\end{lstlisting}

\section{Break and Continue}
\Reflex also supports \Verb+break+ and \verb+continue+ semantics, which work as expected. The following code snippets (which assert correctly) show this behavior.
\begin{lstlisting}[caption={Break in for loop}]
res = [];

for i = 0 to 10 do
   res = res + i;
   if i == 5 do
      break;
   end
end

assert(res == [0,1,2,3,4,5]);
\end{lstlisting}

\begin{lstlisting}[caption={Continue in for loop}]
res = [];

for i = 0 to 10 do
    if i < 5 do
       continue;
    end
    res = res + i;
end

assert(res == [5,6,7,8,9,10]);
\end{lstlisting}

\chapter{Exceptions}
\Reflex supports exceptions in the form of a \Verb+try/catch+ construct. An example will best illustrate the approach.
\begin{lstlisting}[caption={Exception handling}]
// A simple test of exception structure

x = 0;
y = false;

def addIt(var)
   var = var + 1;
   throw "From the function " + var;
   return var;
end

try do
    x = addIt(x);
    println("After function, but not caught");
end
catch e do
    println("Caught exception " + e);
    y = true;
end

assert(x == 0);
assert(y);

\end{lstlisting}

In this example we calla function that will increment our parameter, but the function throws an exception before the parameter is returned. In the exception handler we set the \Verb+y+ variable to true. Both assertions at the end of the script are valid -- $x$ is still zero because the function threw an exception before it could be updated. And $y$ is \verb+true+ because we entered the exception handler.

\Reflex can also catch general exceptions thrown by internal or addin functions.

\chapter{Special operators}
There are four special operators in \Reflex. They are \Verb+-->+ , \verb+<--+, \verb+-->>+ and \verb+<<--+. The operators are known as the push, pull, metapush and metapull operators.

\Reflex scripts are primarily about taking data from \Rapture, manipulating it, and then putting that data back. The push and pull operators can be used to get data from \Rapture and to save it back. The meta versions of the pull and push operators return (or deliver) the metadata about the content, such as who wrote the document, its version and when it was written. Only repositories that support metadata can benefit from these meta operators.

As an example, consider a \Rapture environment with a partition \Verb+test+ and a type in that partition with the name \verb+config+. The script in the following listing will save some data to \Rapture in a configuration document and then later on, retrieve that data and use the information within to control the script. The script also shows an example of initializing a map and writing values to it. When used in this form, the push and pull operators assume a map type on the left hand side and a string on the right.

\begin{lstlisting}[caption={Push and Pull}]
// Data push and pull
config = {};
config['option1'] = true;
config['level'] = 42;

displayName = 'test/official/config/main';

config --> displayName; // Write the map to the document

// Later on in a different script

appConfig <-- displayName;
if appConfig['option1'] do
   println("Level is " + appConfig['level']);
else do
   println("Option1 is not set');
end
\end{lstlisting}

The push and pull operators also work with either a \emph{queue} or a \emph{file} type on the right hand side. For a queue, the operator either puts an entry onto a \Rapture queue or takes one off. For a file, the pull operator returns the contents of the file (as a string) and the push operator writes the string to the file. These uses are discussed in more detail in the relevant sections below on IO.

\section{Meta pull}

The following example yields the output given below the listing:
\begin{lstlisting}[caption={Meta pull}]
meta <<-- 'c_smrs/official/physical/bond/861594AB5';

println("Meta is " + meta);
\end{lstlisting}

\begin{Verbatim}
Meta is {version=1,
         writeTime=1351614168682,
         user=alan,
         comment=FeatureInstaller,
         deleted=false}
\end{Verbatim}


\chapter{User-defined functions}
User-defined functions \index{function} can also be built in \Reflex. The main structure of a function definition is show below:
\begin{Verbatim}

def functionName ( parameters )
    block
end

functionName(parameters);

\end{Verbatim}
A simple example of a function being defined and used is in the following listing.

\begin{lstlisting}[caption={Function definition}]

const prefix = "I'll say ";

def sayWhat(name, what)
   println(prefix + what + " to " + name);
end

sayWhat('Alan', 'hello');
sayWhat('Alan', 42);

\end{lstlisting}

Some important points about function declarations and invocations. When defining a function the parameter types are not defined, just their names. So a developer can be very free with the type of parameters as long as the body of the function can also tolerate the type differences. You can see an example of that in the listing above, where the \Verb+what+ parameter is also passed as a number as well as a string.

Also variables defined outside the scope of a function are not normally accesible from within the function. You either need to pass the variable as a parameter or declare the variable as \Verb+const+ to ensure that it can be accessed within a function. The reason for this is to allow future optimizations of invocations of functions in \Reflex - where the function could actually be executed on a different machine than the one used for the outer script. You can see this in action in the script above with the \verb+prefix+ const.

\chapter{Modules}
\Reflex has the concept of \Verb+modules+ that can be used to extend the functionality of \Reflex through custom Java code that can be deployed alongside the environment. In this way application developers can create (or link to) more complex concepts and can interact with those libraries through normal \Reflex scripts. As an example, in a Financial services application using \Reflex the complete analytics library was exposed to \Reflex users using this technique.

\section{Use in Reflex}
In \Reflex a module is referenced using an \Verb+import+ statement. This statement takes the following form:
\begin{Verbatim}
import "classname" as "modulename" [with ( parameters ) ];
\end{Verbatim}

The classname refers to a Java class that is on the classpath loaded by \Reflex, and the module name is an alias for this module that is used later on in scripts. The classname can omit 'reflex.module' if the class is in that package already. The module name will be converted to a normal Java convention of having first letter capitalization. The module can be initialized with parameters if necessary. To call a function in a module a script writer uses the \emph{\$} prefix on the module name, like in the example below:

\begin{lstlisting}[caption={Module example}]

import testModule as test;

answer = $test.addOne(5);
assert(answer == 6);
\end{lstlisting}

This example refers to a testModule that will be explored in later sections.

\section{Creating a module}
Classes that are referred to in import statements must implement the \Verb+reflex.importer.Module+ interface. This is reproduced below:
\begin{lstlisting}[caption={Module interface}]
public interface Module {
    ReflexValue keyholeCall(String name, List<ReflexValue> parameters);
    boolean handlesKeyhole();
    boolean canUseReflection();
    void configure(List<ReflexValue> parameters);
    void setReflexHandler(IReflexHandler handler);
}
\end{lstlisting}
There are two ways a developer can create a module -- using a keyhole interface and using reflection. A module could support both but would normally support just one. Reflection is preferred for ease of development and rapid extension at a small cost of Java reflection.
\subsection{Keyhole module}
A keyhole module would return \Verb+true+ for the method \verb+handlesKeyhole+. If a module returns true to this method \Reflex will invoke the keyholeCall method for each module method invocation in a \Reflex script. In the example above, a call to \verb+$test.addOne(5)+ would be translated into the following call:

\begin{Verbatim}
List<ReflexValue> params = new ArrayList<ReflexValue>();
params.add(new ReflexValue(5));
ReflexValue result = module.keyholeCall("addOne", params);
\end{Verbatim}

In this way the implementation of the \Verb+keyholeCall+ method must test the value of the \verb+name+ parameter to switch to the appropriate implementation.

\subsection{Reflection module}
A reflection module would return \Verb+true+ for the method \verb+canUseReflection+. If a module returns true to this method \Reflex will look for a method with a very specific signature in the class implementation of the module. If that method exists it will be invoked. The signature is for a method that returns a \verb+ReflexValue+ and takes a single \verb+List<ReflexValue>+ parameter. As an example, the implementation of the \verb+testModule+ demonstrated above could be completely implemented by the following Java class:

\begin{lstlisting}[caption={Test Module}]

package reflex.module;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import reflex.IReflexHandler;
import reflex.ReflexException;
import reflex.importer.Module;
import reflex.value.ReflexValue;

public class TestModule implements Module {

    @Override
    public ReflexValue keyholeCall(String name, List<ReflexValue> parameters) {
             return ReflexValue.VOID;
    }

    @Override
    public boolean handlesKeyhole() {
            return false;
    }

    @Override
    public boolean canUseReflection() {
           return true;
    }

    @Override
    public void configure(List<ReflexValue> parameters) {
    }

    @Override
    public void setReflexHandler(IReflexHandler handler) {
    }

    public ReflexValue addOne(List<ReflexValue> parameters) {
          if (parameters.size() != -1) {
              throw new ReflexException(-1, "addOne needs one parameter!");
          }
          Integer v = parameters.get(0).asInt();
          return new ReflexValue(v.intValue() + 1);
    }
}

\end{lstlisting}

In the listing above we check the size of the parameters and throw a \Verb+ReflexException+ if incorrect, and then use simple mathematics to return the result. Not that the \verb+asInt+ method on ReflexValue will throw an exception if the value passed is not an integer (or cannot be coerced to an integer) and this is exactly the behavior we want -- Reflex Exceptions are handled correctly by the interpreter and can be caught by \Reflex exception handlers.

\chapter{Built-in modules}
\Reflex has a number of built-in modules that have been created to extend \Reflex using commonly used third party (and open source) libraries. All are implemented as \emph{reflection} based modules.
\section{Statistics module}
The statistics module draws on the Apache Commons Math library. The main function computes the statistics associated with a list of values and is called "statistics". It returns a map with three values, the "mean", the "std" (standard deviation) and "median" (the value of the 50th percentile).

The other three functions in the module work with "Frequency" objects. A frequency object is created using the frequency function - it returns a special Reflex Value that can be passed into the other two methods as the first value. The other two methods calculate the number of values that match the value passed (\Verb+frequency_count+) and the cumulative percentage of values up to a value (\verb+frequency_cum_pct+). This is best illustrated by example:

\begin{lstlisting}[caption={Statistics}]
import reflexStatistics as stat;

points = [ 1,2,3,4,5,6,7,8,9,10,100];

res = $stat.statistics(points);

println("Result is " + res);

multiplePoints = [ 1,2,1,1,1,1,2,1,2,4,5,1,2,3,5];

freq = $stat.frequency(multiplePoints);

println("Count of 1 in frequency is " + $stat.frequency_count(freq, 1));

for i = 1 to 5 do
   println("CumPct at " + i + " is " + $stat.frequency_cum_pct(freq, i));
end

\end{lstlisting}
 The result of running this script would yield the following output:
\begin{Verbatim}
Result is {median=6.0, std=28.637229424141385, mean=14.09090909090909}
Count of 1 in frequency is 7
CumPct at 1 is 0.4666666666666667
CumPct at 2 is 0.7333333333333333
CumPct at 3 is 0.8
CumPct at 4 is 0.8666666666666667
CumPct at 5 is 1.0
\end{Verbatim}
\section{Gamma module}
The Gamma module uses the Apache Commons Math library to compute values relating to the $\Gamma$ function and its derivatives.
\subsection{Gamma function}
The gamma function (\Verb+gamma+) takes zero or one parameter. In its no parameter form, it returns the value of the Euler-Mascheroni constant (also known as Euler's constant), and referred to as $\gamma$. With one parameter it reurns the gamma function on the parameter.
\subsection{DiGamma function}
The digamma function (\Verb+digamma+) takes one parameter and returns the digamma function on the parameter.
\subsection{TriGamma function}
The trigamma function (\Verb+trigamma+) takes one parameter and returns the trigamma function on the parameter.
\section{Erf module}
The Erf module uses the Apache Commons Math library to compute Error Function values. It has two functins - \Verb+erf+ reyurns the error function of its parameter, and \verb+erfc+ returns the error function coefficient of its parameter.
\section{Math module}
The math module provides standard support through the Java Math package. The functions exposed are shown in the table below:
\begin{table}[!h]
  \small
\centering
\begin{tabular} { | l | l | p{9cm}  | }
\hline
Function  & Parameters & Description   \\
\hline
pi & none & Returns the constant $\pi$   \\
e & none & Returns the constant $\epsilon$   \\
abs & value & Returns the absolute value of a number  \\
acos & value & Returns the arc-cosine of the number \\
asin & value & Returns the arc-sine of the number \\
atan & value & Returns the arc-tangent of the number \\
atan2 & x,y & Returns the arc-tangent "2 parameter" result of the (x,y) values passed \\
cbrt & value & Returns the cube root of the number \\
ceil & value & Returns the value rounded up to the nearest integer \\
cos & value & Returns the cosine of the value in radians \\
cosh & value & Returns the hyperbolic cosine of the value \\
exp & value & Returns $\epsilon$ raised to the power of the value \\
expm1 & value & Returns $\epsilon^x - 1 $ \\
floor & value & Returns the value rounded down to the nearest integer \\
hypot & x,y & Computes $ \sqrt { x^2 + y^2 } $ \\
log & value & Computes the natural logarithm of the value \\
log10 & value & Computes the base-10 logarithm of the value \\
log1p & x & Computes \Verb^log(1+x)^ \\
max & x,y & Returns the maximum of x or y \\
min & x,y & Returns the minimum of x or y \\
pow & x,y & Returns $x^y$ \\
sin & value & Returns the sine of the angle in radians \\
sinh & value & Returns the hyperbolic sine \\
sqrt & value & Computes $\sqrt x $ \\
tan & value & Computes the tangent of the angle in radians \\
tanh & value & Computes the hyperbolic tangent \\
degrees & value & Converts radians to degrees \\
radians & value & Converts radians to degrees \\
\hline
\end{tabular}
\caption{Math module in \Reflex}
\end{table}

\chapter{Functional Aspects of Reflex}
Functions can be defined in \Reflex and these functions can be passed around as \emph{first class objects} to a number of special in-built functions. This chapter describes these special functions.
\section{map}
The \emph{map} built-in function takes two parameters -- a pre-defined function that takes a single parameter and returns a single value and an array. The \emph{map} function calls the pre-defined function for each element in the passed array, generating a new array which is formed by the return values from this invocation. The return value of the \emph{map} function is this \emph{transformed} array. The size of the array returned will match the size of the array passed as the second parameter.

\begin{lstlisting}[caption={Reflex map function}]
def mapfn(x)
      return x*2;
end

res = map(mapfn, [ 1, 2, 3, 4, 5]);

assert(res == [2,4,6,8,10]);
\end{lstlisting}

The example above demonstrates this. We first define a simple function that doubles its passed parameter "x". We then \emph{map} using this function an array of the first 5 integers. The result is an array of the first five even numbers, as each element in the first array has been multiplied by 2.

\section{filter}
The \emph{filter} built-in function takes two parameters -- a pre-defined function that takes a single parameter and returns either true or false. The \emph{filter} function calls the pre-defined function for each element in the passed array. If that function returns true the parameter passed to the filter function is added to an array that will be ultimately returned by the \emph{filter} function. In this way the return array will only contain the values in the passed array for which the "filter function" returns true.

\begin{lstlisting}[caption={Reflex filter function}]
def filterFn(x)
      return x % 2 == 0;
end

res = filter(filterFn, [ 1, 2, 3, 4, 5]);

assert(res == [2,4]);
\end{lstlisting}

In the above example we define a function that returns whether a passed number is even -- a number is even if the result after dividing by 2 is zero, and this is what this function returns.

After passing this function and an array of the first five integers to the filter function we produce a new array that just contains those elements that are even -- in this case the numbers 2 and 4.

\section{any}
The \emph{any} built-in function takes two parameters -- the first is a built-in function similar to that used by the filter function, one that returns true or false. The second parameter is an array. The \emph{any} function returns true if \emph{any} of the elements in the input array returns \emph{true} when passed through the built-in function. Note that the test will stop as soon as \emph{any} element returns true, and the elements are tested in the order they are given in the passed array.

\begin{lstlisting}[caption={Reflex any function}]
def lessThan5(x)
      return x < 5;
end

l1 = [ 1, 2 , 3, 7 ];
l2 = [ 7, 8, 9, 10 ];

res1 = any(lessThan5, l1);
res2 = any(lessThan5, l2);

assert(res1 == true);
assert(res2 == false);
\end{lstlisting}

In this example we define a simple function "lessThan5" that returns true if the passed parameter is less than 5. We then call the \emph{any} function with two different arrays -- one where there is a number less than 5 (l1) and one where none of the numbers are less than 5 (l2). The first call returns true (there is at least one element in l1 that is less than 5) and the second call returns false (there are no elements in l2 that are less than 5).

\section{all}
The \emph{all} built-in function works in a similar way to the \emph{any} function. It takes two parameters -- the first is a built-in function similar to that used by the filter function, one that returns true or false. The second parameter is an array. The \emph{all} function returns true if \emph{all} of the elements in the input array returns \emph{true} when passed through the built-in function. It will return false if \emph{any} of the elements in the input array returns \emph{false} when passed through the built-in function. The function will stop checking if it sees any check returning false.

\begin{lstlisting}[caption={Reflex all function}]
def greaterThan(x)
      return x > 5;
end

l1 = [ 1, 2 , 3, 7 ];
l2 = [ 7, 8, 9, 10 ];

res1 = all(greaterThan5, l1);
res2 = all(greaterThan5, l2);

assert(res1 == false);
assert(res2 == true);
\end{lstlisting}

In this example we define a simple function "greaterThan5" that returns true if the passed parameter is greater than 5. We then call the \emph{all} function with two different arrays -- one where there is a number less than 5 (l1) and one where none of the numbers are less than 5 (l2). The first call returns false (all of the elements are not greater than 5 in l1) and the second call returns true (all of the elements are greater than 5).

\section{takewhile}
The \Reflex function \emph{takewhile} takes two parameters -- the first is a function that takes a single parameter and returns true or false. The second is an array. The return value of the function consists of all of the elements of the input array \emph{up to the point} at which the return value from passing the array element through the passed function retruns true. We in effect "take the elements of the input array while the test is true".

\begin{lstlisting}[caption={Reflex takewhile example}]
def lessThan5(x)
      return x < 5;
end

l1 = [ 1, 2 , 3, 7 ];
l2 = [ 1, 7, 8, 9, 5, 10 ];

res1 = takewhile(lessThan5, l1);
res2 = takewhile(lessThan5, l2);

assert(res1 == [1,2,3]);
assert(res2 == [1]);
\end{lstlisting}

In this example we use a standard "lessThan5" function that returns true if a number is less than 5. We than pass that to the \emph{takewhile} function using two different arrays. The first, \emph{l1}, has a 4th element (7) which is greater than 5, and the result of calling \emph{takewhile} is to return only the first 3 elements. The second, \emph{l2}, has the 2nd element greater than 5 and therefore the result of the \emph{takewhile} call is to only return the first element of the array.

\section{dropwhile}
The \Reflex \emph{dropwhile} function is similar to \emph{takewhile} -- it takes two parameters, a test function that accepts on parameter and returns true or false and an input array. The result of calling \emph{dropwhile} is to remove elements from the input array while the test function returns true. As soon as the test function returns false the checking is stopped and the remaining elements of the input array are returned. We are effectively "dropping elements of the array while the test function returns true".

\begin{lstlisting}[caption={Reflex dropwhile example}]
def lessThan5(x)
      return x < 5;
end

l1 = [ 1, 2 , 3, 7 ];
l2 = [ 1, 7, 8, 9, 5, 10 ];

res1 = dropwhile(lessThan5, l1);
res2 = dropwhile(lessThan5, l2);

assert(res1 == [7]);
assert(res2 == [7,8,9,5,10]);
\end{lstlisting}

This example is similar to the \emph{takewhile} example - and in this case the return value from the \emph{dropwhile} call is the exact complement of the \emph{takewhile} call. If we concatenated the result of a \emph{takewhile} call to the result of a \emph{dropwhile} call with the same parameters we would get the same input array passed in.

\section{splitwith}
The \Reflex \emph{splitwith} function works on the property that the \emph{takewhile} and \emph{dropwhile} functions are complementary -- they each select a different part of the passed input array. The result of \emph{splitwith} (which takes the same parameters as the other functions -- a function that returns either true or false, and an input array) is to return an array of two values -- one the result of calling \emph{takewhile} and one the result of calling \emph{dropwhile}.

\begin{lstlisting}[caption={Reflex splitwith example}]
def lessThan5(x)
      return x < 5;
end

l1 = [ 1, 2 , 3, 7 ];
l2 = [ 1, 7, 8, 9, 5, 10 ];

res1 = splitwith(lessThan5, l1);
res2 = splitwith(lessThan5, l2);

assert(res1 == [[1.0, 2.0, 3.0], [7.0]]);
assert(res2 == [[1.0], [7.0, 8.0, 9.0, 5.0, 10.0]]);
\end{lstlisting}

In the above example we split the array at the point where the first element is \emph{not} less than 5 - so that the first element in the return value is all the elements \emph{to the left} of that point, and the second element in the return value is all of the elements \emph{to the right} of that point.

\section{fold}
\emph{Fold} is a classic accumulator technique in functional programming -- it takes three parameters, the first being a function that takes two parameters (an accumulator and an input parameter, returning a value), the second being an initial value of an \emph{accumulator} and the third an input array.

The function works by calling the passed function with the initial value of the accumulator and the first element of the input array. The return value of calling this function is the \emph{new} accumulator that is passed to the invocation of the passed function with the second element. This continues for all elements and the return value of the \emph{fold} function is the final return value of the final call for the final element.

\begin{lstlisting}[caption={Reflex fold example}]
def totalFn(total, x)
      return total + x;
end

def multFn(total, x)
      return total * x;
end

input = [ 1, 2, 3, 4, 5];
res = fold(totalFn, 0, input);
res2 = fold(multFn, 1, input);

assert(res == 15);
assert(res2 == 120);
\end{lstlisting}

In this example we define two functions -- one that adds the two passed parameters and returns their sum (\emph{totalFn}) and one that multiplies the two passed parameters and returns the result (\emph{multFn}). We then call the \emph{fold} function on a simple input array (the first 5 integers) with each of these functions. For the \emph{totalFn} we set the initial value of the accumulator to be zero and for the \emph{multFn} we set the initial value to be 1 (a value of zero would result in every number being multiplied by zero).

The calls to the \emph{totalFn} work according to the table below:

\begin{table}[!h]
\centering
\begin{tabular} { | r | r | r  | }
\hline
Input  & Accumulator & Result   \\
\hline
1 & 0 & 1 \\
2 & 1 & 3 \\
3 & 3 & 6 \\
4 & 6 & 10 \\
5 & 10 & 15 \\
\hline
\end{tabular}
\caption{Total using fold}
\end{table}

With the result of 15 being returned by the fold function.

For the \emph{multFn} we have the following steps:

\begin{table}[!h]
\centering
\begin{tabular} { | r | r | r  | }
\hline
Input  & Accumulator & Result   \\
\hline
1 & 1 & 1 \\
2 & 1 & 2 \\
3 & 2 & 6 \\
4 & 6 & 24 \\
5 & 24 & 120 \\
\hline
\end{tabular}
\caption{Multiply using fold}
\end{table}

\chapter{Suspension and Coordination}
\Reflex can be hosted in an environment that can support suspension and eventual resumption. On the one hand, suspension is useful to simply \emph{pause} the running script for a set amount of time in order to wait for some external activity to take place. Upon resumption from suspension the script continues from where it was suspended. Another use case involves a script actively waiting (\emph{coordinating}) with the activity of another script -- when the target script is completed the suspending (waiting) script automatically resumes.


In the \Rapture context the suspension involves freezing the context of the script -- its variables, the calling parameters, the modules loaded and the exact point of suspension -- and then either placing the suspended script onto the \Rapture pipeline for resumption as soon as possible \emph{or} making a scheduled task entry for resumption at a future point in time. The important aspect of this suspension is that the resumption can take place on a different \Rapture server to that which originally ran the script, and in fact due to the virtual nature of \Rapture servers the original server may no longer exist.

\section{Suspension functions}
\subsection{Suspend}
The \verb+suspend+ function takes one parameter - a number that represents a desired amount of time to suspend. The actual amount of time suspended will vary depending on the container that the script is running on. To a script writer it should be considered as a \emph{pause} in the execution of a script. A script can be suspended any number of times.

\begin{lstlisting}[caption={Reflex Page Script Example}]
// Suspend example

i = 5;
suspend(10); // Suspend for approximately 10 seconds
println("I is " + i);

\end{lstlisting}

The above listing would ultimately result in the text:

\begin{Verbatim}
I is 5
\end{Verbatim}

to be placed onto the output context of the script.

\subsection{@Call}

The \verb+@call+ function makes an asynchronous request to execute a script that is passed as the first parameter to the function. The second parameter to this function forms the parameters to the invoked script. The request is placed onto the \Rapture pipeline for execution, and a handle to that request is returned from this function. This handle (which is in fact a string) can be used in the \verb+@wait+ and \verb+@status+ functions described below.

\begin{lstlisting}[caption={Example @Call}]

program = "println('Hello world')";
handle = @call(program, {});

\end{lstlisting}

In the above example we pass in an empty parameter set \verb+{}+ to the script being invoked.

The \verb+@call+ function internally uses the connect to the \Rapture API environment for execution -- the script will be executed on that environment which is not necessarily the same environment that is running the script making the \verb+@call+ invocation.

\subsection{@CallScript}
The \verb+@callScript+ function is very similar to the \verb+@call+ function above, except that it refers to a script that is already hosted on a \Rapture server. The single script parameter of the \verb+@call+ function is replaced by two parameters to reference this script -- the partition and the name of the script. As with \verb+@call+, this function returns a handle that can be used in \verb+@wait+ and \verb+@status+.

\begin{lstlisting}[caption={Example @CallScript}]

handle = @callScript("testPartition", "myScript", {});

\end{lstlisting}

\subsection{@Status}

The \verb+@status+ function returns a map containing details of the current execution of a script that was orignally scheduled through an \verb+@call+ or \verb+@callScript+ invocation.

\begin{lstlisting}[caption={Example @Status}]

program = "println('Hello world');";
handle = @call(program, {});

println(@status(handle));

\end{lstlisting}

A typical output from the above program is reproduced below (assuming the script was actually executed in the time between the invocation and the status call).

\begin{Verbatim}
{
   state=COMPLETED,
   taskId=2abd8d30-f7ea-4956-908c-e04737d64c0e,
   relatedTaskId=,
   creationTime=1354632237825,
   startExecutionTime=1354632237827,
   endExecutionTime=1354632237829,
   suspensionCount=0,
   output=["Hello world"]
}
\end{Verbatim}

The resultant status document has an important \verb+state+ field that can have the values of SUBMITTED, RUNNING, COMPLETED, FAILED or SUSPENDED. The taskId corresponds to the handle of the call, the time fields are set dependant on the execution of the task and the suspensionCount field indicates the number of times this task has been suspended. Finally the output field is a list of strings that contain any output from any print or println statements in the executed script.

\subsection{@Wait}
The \verb+@wait+ function waits for an array of handles to be either COMPLETED or FAILED. It can be used to suspend the current script until any invoked \verb+@call+ or \verb+@callScript+ scripts have completely finished executing. Like \verb+suspend+ it takes a parameter that indicates the amount of time it should expect to wait between suspensions before waking up to check the status of the called scripts. An example is reproduced below:

\begin{lstlisting}[caption={Call and Wait example}]
handles = [];

for i = 1 to 50 do
    program = "println('hello from " + i + " ');";
    handle = @call(program, {});
    handles = handles + handle;
end

@wait(10, handles);

for h in handles do
    println(@status(h));
end
\end{lstlisting}
In this example the master script invokes 50 asynchronous scripts, each with a different output. Once they are all completed it enumerates through the executed scripts printing their eventual status.

\chapter{Reflex Page Scripting}
\Reflex can also be hosted within a web server to serve content through the execution of \Reflex scripts. The function can be enabled in a web server that supports servlets by routing file requests through one of two servlet classes provided as part of the \Rapture Core library.

\section{Reflex File Serving}
\Reflex scripts that are accessible through the resources of the web server can be served through the \emph{ReflexScriptPageServlet}. Often this servlet will be bound to a file name extension "rfx" and can have a resource path configured to prepend to all resource requests. A typical configuration (part of \Verb+web.xml+) is reproduced below:

\begin{Verbatim}
<servlet>
   <servlet-name>REFLEX</servlet-name>
   <servlet-class>rapture.server.web.servlet.ReflexScriptPageServlet
   </servlet-class>
   <init-param>
     <param-name>resourcePath</param-name>
     <param-value>/</param-value>
   </init-param>
</servlet>
<servlet-mapping>
   <servlet-name>REFLEX</servlet-name>
   <url-pattern>*.rfx</url-pattern>
</servlet-mapping>
\end{Verbatim}

The servlet works by attempting to load the resource specified in the url of the request (that ends in rfx), prepending the resourcePath parameter to that resource name. It loads this file as a \Reflex script and executes it with a "web" parameter injected into the context containing any parameters passed to the script.

Any "println" output from the script is sent to the http client making the request. A typical use in a \Rapture environment is to convert a result into a \emph{json} string and return that for parsing by (for example) an Ajax call.

An example script that produces a json result containing the features installed in a \Rapture environment is reproduced below:

\begin{lstlisting}[caption={Reflex Page Script Example}]
// Returns the list of features
features = #feature.getInstalledFeatures();
ret = [];
for feature in features do
    inner = {};
    inner['feature'] = feature['feature'];
    inner['description'] = feature['description'];
    ver = feature['version'];
    inner['version'] = ver['major'] + '.' + ver['minor'] + '.' + ver['release'];
    ret = ret + inner;
end
println(json(ret));
\end{lstlisting}

\section{Reflex Script Serving}
\Reflex scripts that are stored in \Rapture can also be executed in this manner, using the \emph{ReflexRefScriptPageServlet}. This will also typically be bound to a file extension, but instead of the path of the resource reflecting a real resource in the web server it is referencing a means to load the script from \Rapture -- in this way it will typically be of the form -- \Verb+partition/scriptPath+. Any extension on the resource is automatically removed from the resource.

A typical configuration for this servlet is reproduced below:

\begin{Verbatim}
<servlet>
    <servlet-name>REFLEXREF</servlet-name>
    <servlet-class>rapture.server.web.servlet.ReflexRefScriptPageServlet
    </servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>REFLEXREF</servlet-name>
    <url-pattern>*.rrfx</url-pattern>
</servlet-mapping>
\end{Verbatim}

The execution of the script follows an identical pattern (once loaded) to that of the script file approach shown in the previous section.

\chapter{Built-in functions}
\Reflex has a large number of built-in functions that extend the power of the language in a more native way. The \Verb+println+ function was introduced earlier. This section describes all of the built-in functions in \Reflex.

\section{Println}
\index{println}
\begin{Verbatim}
println( expression )
\end{Verbatim}

The \Verb+println+ function prints to the registered output handler the single parameter passed, which is coerced to a string type if it is not already. In most implementations of \Reflex the output handler is wired to be either standard out (the console), the Eclipse console window or the standard log file.
\begin{lstlisting}[caption={println}]
// Println example
println("Hello, world!");
println(5);
println({}); // Prints an empty map
println("one two " + 3);
\end{lstlisting}

\section{Print}
\index{print}
\begin{Verbatim}
print( expression )
\end{Verbatim}

The \Verb+print+ function is identical to \verb+println+ except that it does not automatically terminate the output with a carriage return.
\begin{lstlisting}[caption={print}]
// Print example
print("Hello, world!");
print(" And this would be on the same line.");
println(""); // And now force a carriage return
\end{lstlisting}

\section{TypeOf}
\index{typeof}

\begin{Verbatim}
typeof( expression )
\end{Verbatim}

The \Verb+typeof+ function can be used to determine the type of an expression, which can be a variable identifier as well. The return from the \verb+typeof+ function is a string, which can take the values in the table \vref{tab:TypeOf}.

\begin{table}[h!]
\centering
\begin{tabular} { | c | c | }
\hline
Internal Type     &  Return Value \\
\hline
String & "string" \\
Number &"number" \\
Boolean & "bool" \\
List & "list" \\
Map & "map" \\
Date & "date" \\
Time & "time" \\
File & "file" \\
Queue & "queue" \\
No value & "void" \\
Null value & "null" \\
All else & "object" \\
\hline
\end{tabular}
\label{tab:TypeOf}
\caption{typeof function return values}
\end{table}

An example of the use of \Verb+typeof+ function is shown below:

\begin{lstlisting}[caption={Typeof example}]
// typeof example
a = "This is a string";

if typeof(a) == "string" do
   println("Yes, 'a' is a string");
end

\end{lstlisting}

\section{Assert}
\index{assert}
\begin{Verbatim}
assert( boolean-expression )
\end{Verbatim}

The \Verb+assert+ function is used to test its single parameter for truth. If the expression does not evaluate to true the \Reflex script will abort abnormally.

\begin{lstlisting}[caption={Assert example}]
// assert example

assert(true);
assert(typeof(" ") == "string");

\end{lstlisting}

\section{Size}
\index{size}

\begin{Verbatim}
size( list-expression | string-expression )
\end{Verbatim}

The \Verb+size+ function returns the size of its single parameter. It is only applicable for strings and lists. For a string the size is the length of the string, for a list it is the size of the list (the number of elements in the list). For convenience, \verb+size(null)+ evaluates to zero.

\begin{lstlisting}[caption={Size example}]
// size example
a = [1,2,3,4];

if sizeof(a) == 4 do
   println("Yes, that list has four elements");
end

\end{lstlisting}
\section{Keys}
\index{keys}

\begin{Verbatim}
keys( map-expression )
\end{Verbatim}

The \Verb+keys+ function takes a single map parameter, and returns a list of strings that corresponds to the keys of the associative map. It is useful when you need to iterate over a map.

\begin{lstlisting}[caption={Keys example}]
// keys example

a = { 'one' : 1, 'two' : 2 };
b = keys(a);

for k in b do
   println("Key = " + k + ", value is " + b[k]);
end

\end{lstlisting}

\section{Debug}
\index{debug}

\begin{Verbatim}
debug( expression )
\end{Verbatim}

The \Verb+debug+ function works in a similar way to the \verb+println+ function, except that the output is sent to any attached debugger instead of to the console. In some \Reflex installations this will mean the same thing.

\begin{lstlisting}[caption={Debug example}]
// debug example

println("This will appear in one place");
debug("This will appear in the debugger");

\end{lstlisting}

\section{Date}
\index{date}

\begin{Verbatim}
date( )
date( string-expression )
\end{Verbatim}

The \Verb+date+ function returns a date object. If called with zero parameters the object will be initialized to the current date. It can also take a single string parameter which must be a date formatted as "yyyyMMdd". The date object will be initialized to the date represented by that string.

\begin{lstlisting}[caption={Date example}]

today = date();
aRealDate = date('20120101');

println("Today is " + today + ", today is fun");
println("The start of the year 2012 is " + aRealDate);

\end{lstlisting}

\section{Time}
\index{time}

\begin{Verbatim}
time( )
time( string-expession )
\end{Verbatim}

The \Verb+time+ function returns a time object. If called with zero parameters the object will be initialized to the current time. It can also take a single string parameter which must be a time formatted as "HH:mm:ss". The time object will be initialized to the time represented by that string.

\begin{lstlisting}[caption={Time example}]
// time example

now = time();
then = time('11:00:01');

println("What time is now? " + now);

\end{lstlisting}

\section{ReadDir}
\index{readdir}

\begin{Verbatim}
readdir( string-expression | file-expression)
\end{Verbatim}

The \Verb+readdir+ function returns the contents of a directory as a list of file values, although its behavior is really determined by the IO handler installed in the \Reflex environment. The function accepts either a string (which corresponds to the name of a folder available to the handler) or a file (returned by the \verb+file+ function or a different call to \verb+readdir+).

\begin{lstlisting}[caption={readdir example}]
// readdir example
// Recursively look for folders

def readFolder(folder)
    println("Looking at " + folder);
    filesAndFolders = readdir(folder);
    for fAndF in filesAndFolders do
        if isfolder(fAndF) do
           readFolder(fAndF);
        end
    end
end

readFolder('/tmp');

\end{lstlisting}

This example starts with the \Verb+/tmp+ folder and enumerates all folders below that recursively, printing out the name of each folder found.

\section{IsFile}
\index{isfile}

\begin{Verbatim}
isfile( string-expression | file-expression )
\end{Verbatim}

The \Verb+isfile+ function evaluates its single argument (which needs to be a file or a string) and returns a boolean indicating whether the argument is actually a file.

\begin{lstlisting}[caption={IsFile example}]
// isfile example

const name = '/tmp';

if isfile(name) do
   println(name + " is a file!");
else do
   println(name + " is not a file!");
end

\end{lstlisting}

\section{IsFolder}
\index{isfolder}

\begin{Verbatim}
isfolder( string-expession | file-expression)
\end{Verbatim}

The \Verb+isfolder+ function evaluates its single argument (which needs to be a file or a string) and returns a boolean indicating whether the argument is actually  folder.

\begin{lstlisting}[caption={IsFolder example}]

// isfolder example

const name = '/tmp/out.log';

if isfolder(name) do
   println(name + " is a folder!");
else do
   println(name + " is not a folder!");
end

\end{lstlisting}

\section{File}
\index{file}
\begin{Verbatim}
file( string-expression )
\end{Verbatim}

The \Verb+file+ function creates a \Reflex file object from a string, where the string is assumed to be an absolute reference to a real file or folder. Files can be read by the \verb+pull+ operator ($<--$) and written to by the \verb+push+ operator ($-->$).

\begin{lstlisting}[caption={File example}]
// file example

a = "/tmp/test.txt";
data = "This is some text\n";

aFile = file(a);

data --> aFile;

b = "/tmp/test.txt";
bFile = file(b);

data2 <-- bFile;

assert(data == data2);
\end{lstlisting}

\section{Delete}
\index{delete}
\begin{Verbatim}
delete(file or string expression);
\end{Verbatim}

The \Verb+delete+ function either attempts to remove a file from the file system (if supported) or removes a document from a repository.
\begin{lstlisting}[caption={Delete example}]
a = "/tmp/test.txt";
data = "This is some text\n";

aFile = file(a);

data --> aFile;
assert(isFile(aFile));

delete(aFile);
assert(!isFile(aFile));

\end{lstlisting}
\section{Difference}
\begin{Verbatim}
diff(list1, list2)
\end{Verbatim}
The difference function compares two lists and returns the elements that are not in both of them.
\begin{lstlisting}[caption={Difference example}]
a = [1,2,3];
b = [3,4,5];

diff = difference(a,b);

println("diff is " + diff);
// Returns 1,2,4,5
\end{lstlisting}
The function works on lists of numbers or lists of strings.
\section{Unique}
\begin{Verbatim}
uniqueq(list1, list2)
\end{Verbatim}
The unique function compares two lists and returns only those elements that are not in common between the lists.
\begin{lstlisting}[caption={Unique example}]
a = [1,2,3];
b = [3,4,5];

un = unique(a,b);

println("unique is " + un);
// Returns 1,2,4,5
\end{lstlisting}
The function works on lists of numbers or lists of strings.
\section{Json}
\index{json}
\begin{Verbatim}
json( map-expression )
\end{Verbatim}

The \Verb+json+ function converts a map into a JSON formatted string that represents the contents of that map.

\begin{lstlisting}[caption={Json example}]
// json example
a = { 'one' : 1, 'two' : 2 };

a1 = "" + a;
a2 = json(a);

assert(a1 == '{ one=1, two=2 }';
assert(a2 == '{ "one" : 1, "two" : 2 }';
\end{lstlisting}

Note that the default "string" representation of a map is not a json document, you must call the \Verb+json+ function for this.

\section{FromJson}
\index{fromjson}

\begin{Verbatim}
map = fromjson( string-expression )
\end{Verbatim}

The \Verb+fromjson+ function is the reverse of the \verb+json+ function. It takes a JSON formatted string and converts it to an associative map object.

\begin{lstlisting}[caption={FromJson example}]
// fromjson example
a = '{ "alpha" : 1, "beta", 2 };

b = fromjson(a);

assert(b['alpha'] == 1);

\end{lstlisting}

\section{MD5}
\index{md5}
\begin{Verbatim}
string = md5(string-value);
\end{Verbatim}

The \Verb+md5+ function returns a string that is an md5 hash of its passed string parameter. As elements in \Rapture such as passwords are never passed in none-hashed form, this function is useful in computing values that should be passed over an insecure link.

\begin{lstlisting}[caption={MD5 example}]
toHash = "password";
hash = md5(toHash);

println("Hash of " + toHash + " is " + hash);
\end{lstlisting}

\section{Uuid}
\index{uuid}
\begin{Verbatim}
string = uuid( )
\end{Verbatim}

The \Verb+uuid+ function generates a new unique string that can be used as a unique id.

\begin{lstlisting}[caption={UUID example}]
// uuid example
a = uuid();
b = uuid();

assert(a != b);

println(a + " is not the same as " + b);

\end{lstlisting}

\section{Wait}
\index{wait}

\begin{Verbatim}
wait( string )
wait( string, int, int )
wait( process )
\end{Verbatim}

The \Verb+wait+ function is a convenience function that waits for a document to exist in \Rapture. The document name is provided in the first parameter and the optional second and third parameters control the retry interval (wait between checks) and retry count (how many times to check). The return value for the function is either the contents of the document (as a map) or null (if the document did not exist after the interval requested).

Finally, \Verb+wait+ can also be used to wait on a process object returned by the \verb+spawn+ command.

\begin{lstlisting}[caption={Wait example}]
// wait example

displayName = 'test/official/config/testData';

// Assume the above does not exist at the moment.

result = wait(displayName);

assert(result == null);

value = {};
value --> displayName;

result = wait(displayName);

assert(result == {});
\end{lstlisting}

\section{Chain}
\index{chain}

\begin{Verbatim}
result = chain( string-expression )
result = chain( string-expression, map-expression )
\end{Verbatim}

The \Verb+chain+ function is a way of executing a second script in \Reflex from a first script. The script is provided as the first string argument and can be passed in an optional parameter map as the second argument. The return value from \verb+chain+ is the return value from the called script.

\begin{lstlisting}[caption={Chain example}]
// chain example
a = "println('The parameter is ' + p); return true;";

res = chain(a, { 'p' : 42 });

println(The result is " + res);

\end{lstlisting}

The output from executing the script above would be:
\begin{Verbatim}
The parameter is 42
The result is true
\end{Verbatim}

\section{Signal}
\index{signal}

\begin{Verbatim}
signal( string-expression, map-expression )
\end{Verbatim}

The \Verb+signal+ function is the mirror of the \verb+wait+ function in \Reflex. The \verb+signal+ function creates a document in \Rapture with the given displayname and value. It's really a synonym for \verb+ value --> displayName +.

\begin{lstlisting}[caption={Signal example}]
// signal example

signal('test/official/config/doc', { 'hello' : 1 });

assert(wait('test/official/config/doc') == { 'hello' : 1 });

\end{lstlisting}

\section{Sleep}
\index{sleep}

\begin{Verbatim}
sleep( int-expression )
\end{Verbatim}

The \Verb+sleep+ function pauses the \Reflex script for the number of milliseconds specified in the passed parameter.

\begin{lstlisting}[caption={Sleep example}]
// typeof example

for x = 0 to 10 do
   sleep(100);
   if null != wait('test/official/config/doc') do
        x = 10;
   end
end

\end{lstlisting}

\section{Rand}
\index{rand}

\begin{Verbatim}
rand( number-expession )
\end{Verbatim}

The \Verb+rand+ function returns an integer number between 0 and the passed parameter.

\begin{lstlisting}[caption={Rand example}]
values = [];
for i = 1 to 10 do
   values = values + rand(10);
end

println("Here is a list of random numbers - " + values);

\end{lstlisting}

\section{Spawn}
\index{spawn}

\begin{Verbatim}
spawn( list-expression )
spawn( list-expression, map-expression, file-expression)
\end{Verbatim}

The \Verb+spawn+ command, where supported, provides a mechansim for spawning a child process. The return value is a special \emph{process} object that can be used in a \emph{pull} context (to retrieve the standard output from the process) and by the \verb+wait+ function to wait for it to finish.

The first parameter to the spawn command is a list of parameters to pass to the process. The first member of this list is the process to execute, the rest are parameters to pass to this process.

The second parameter is a map expression that defines the \emph{environment} of the process.

The third parameter is a file object that defines the folder the process should be run in.

\begin{lstlisting}[caption={Spawn example}]
env = { "PATH" : "/bin" };
folder = file('/tmp');
program = [ '/bin/ls' , '-l' ];

p = spawn(program, env, folder);

wait(p);

out <-- p;

println("output from process is " + out);
\end{lstlisting}

\section{Defined}
\index{defined}

\begin{Verbatim}
boolean = defined( identifier )
\end{Verbatim}

The \Verb+defined+ function returns true if the variable identifier passed in is known to \Reflex at this point.

\begin{lstlisting}[caption={Defined example}]
a = "This is a string";

assert(defined(a) == true);
assert(defined(b) == false);

\end{lstlisting}

\section{Round}
\index{round}

\begin{Verbatim}
integer = round( number-expression )
\end{Verbatim}

The \Verb+round+ function takes a floating point number argument and returns an integer result that is the closest integer to that value.

\begin{lstlisting}[caption={Round example}]

a = 1.23;
b = 1.56;

assert(round(a) == 1);
assert(round(b) == 2);
\end{lstlisting}

\section{Lib}
\index{lib}

\begin{Verbatim}
Library = lib( string-expression )
\end{Verbatim}

\Reflex has the ability to embed $3^{rd}$ party code within the language. The definition of how to do this is defined in a later section, but the \Verb+lib+ command is the way a $3^{rd}$ party library is linked in with \Reflex. The string parameter to the \verb+lib+ function is the name of a loadable class that implements the \verb+IReflexLibrary+ interface.

The return value from this function is a special \emph{library} object that can be used in the \Verb+call+ function.

\begin{lstlisting}[caption={Lib example}]

mylib = lib('rapture.addins.BloombergData');

\end{lstlisting}

\section{Call}
\index{call}

\begin{Verbatim}
result = call( library-expression,
               string-expression,
               map-expression )
\end{Verbatim}

The \Verb+call+ function takes a library loaded with the \verb+lib+ function and calls a function within that library. The function name is passed as the second parameter and any parameters to the internal function are passed in the third parameter. The result of calling the function is implementation specific.

\begin{lstlisting}[caption={Call example}]

mylib = lib('rapture.test');

result = call(mylib, 'testFn', { 'param' : 42 } );

\end{lstlisting}

\section{Template}
\index{template}

\begin{Verbatim}
result = template(string-expression, map-expression)
\end{Verbatim}

The \Verb+template+ function takes a string "template" and applies parameters to that template to generate a resulting string where the variables in the template have been replaced with the value of the parameters. Internally \Reflex uses the popular \emph{stringtemplate} library for this task.

\begin{lstlisting}[caption={Template example}]

tmp = 'Hello <what>';
param = { 'what' : 'world' };

val = template(tmp, param);

println(val);

assert(val == 'Hello world');

\end{lstlisting}

\section{Cast}
\index{cast}

\begin{Verbatim}
value = cast ( expression, string-expression )
\end{Verbatim}

The \Verb+cast+ function attempts to coerce an expression into either a string or a number. When coercing to a string, a simple "toString" operator is called on the underlying data type. When converting to a number the "toString" value of the expression is passed into a number parser to attempt to convert it to the internal \Reflex number type.

\begin{lstlisting}[caption={Cast example}]
a = "1.0";
b = cast(a, "number");
assert(a == 1.0);

y = 1.0;
z = cast(y, "string");
assert(z == '1.0');

\end{lstlisting}

\section{Merge}
\index{merge}
\begin{Verbatim}
value = merge(map-expression, map-expression, ...)
\end{Verbatim}

The \Verb+merge+ function merges map variables together in \Reflex. The rules are that the right hand side of the merge operation will always "win" in such a merge, so that if a key is present in the left hand side \emph{and} the right hand size it will be the value of the right hand side that will contain the new value. The merge is recursive if the values being merged within the maps are themselves maps -- each lower level map is merged separately.

\begin{lstlisting}[caption={Merge example}]
a = { 'one' : 1 };
b = { 'two' : 2 };
c = merge(a, b);
assert(c == { 'one' : 1, 'two' : 2 });

a = { 'one' : 1 };
b = { 'one' : 'un' };
c = merge(a, b);
assert(c == { 'one' : 'un' });

a = { 'inner' : { 'one' : 1 }};
b = { 'inner' : { 'two' : 2 }};
c = merge(a,b);
assert(c == { 'inner' : { 'one' : 1, 'two' : 2 }});

\end{lstlisting}

Merge can take any number of arguments. The first argument is merged with an empty map, which is then merged with the next parameter and so on. The return value is the merged value, the parameters are unchanged by this function.

\section{Merge If}
\index{mergeif}
\begin{Verbatim}
value = mergeif(map-expression, map-expression, ...)
\end{Verbatim}

The \Verb+mergeif+ function works in a very similar way to the \verb+merge+ function, except that it will not overwrite an existing value. If the same key exists in both maps and the values associated with those keys are also maps then it will also perform a recursive \verb+mergeif+ on those lower level maps.

\begin{lstlisting}[caption={Merge If example}]
a = { 'one' : 1 };
b = { 'two' : 2 };
c = mergeif(a, b);
assert(c == { 'one' : 1, 'two' : 2 });

a = { 'one' : 1 };
b = { 'one' : 'un' };
c = mergeif(a, b);
assert(c == { 'one' : '1' });
\end{lstlisting}

\section{Archive}
\index{archive}
\begin{Verbatim}
value = archive( string-expression )
\end{Verbatim}
The \Verb+archive+ command is used to create a special type of \verb+file+ object that tracks a ZIP archive. You can interact with the object in either read mode or write mode.
\subsection{Write Mode}
In write mode you use the push operator (\Verb+-->+) to send either a simple map to an entry in the file or a two element list - the first element being the name of the entry and the second element being the map data.

After all of the data has been "pushed" to the zip archive the file should be closed through the \Verb+close+ function call.

A typical use of an archive is shown in the listing below:
\begin{lstlisting}[caption={Write to Archive example}]
arcFile = archive("test.zip");

dataEntry1 = { "dataField1" : 42, "data2" : "A string" };
dataEntry2 = { "dataField1" : 34, "data3" : "A different string"};

dataEntry1 --> arcFile;
["DataEntryTwo", dataEntry2 ] --> arcFile;

close(arcFile);
\end{lstlisting}

In this example we create a zip file with two "files" - the first "file" has a default name and the value of the variable \Verb+dataEntry1+. The second entry has the name "DataEntryTwo" with the value of the variable \verb+dataEntry2+. The \verb+archive+ command is useful for creating backups of large amounts of \Rapture data.

\subsection{Read Mode}
In read mode you use the pull operator (\Verb+<--+) to retrieve data from the zip file, in the same order you pushed it on. The returned value is a map with two entries - a \verb+data+ entry contains the value of this file (its contents as a map) and the \verb+displayName+ entry contains the name of the entry. Reading the archive generated in the listing above is show in the example below:

\begin{lstlisting}[caption={Read from archive example}]
arcFile = archive("test.zip");

dataRecord1 <-- arcFile;
dataRecord2 <-- arcFile;

close(arcFile);

println("First record data is " + dataRecord1['data']);
println("Second record data is " + dataRecord2['data']);
\end{lstlisting}

\section{Sort}
\index{sort}
\begin{Verbatim}
value = sort( map or list-expression, boolean-expression )
\end{Verbatim}
The sort function takes a map or a list and sorts it. The return value is the sorted array or map. The
values of the list or the keys of the map must be strings and a simple lexical sort is performed. The second
parameter is whether the return value should be sorted in ascending (true) or descending (false) order.

\begin{lstlisting}[caption={Sort example}]
x = ['a','c','d','b'];
y = sort(x, true);
assert(y == ['a','b','c','d']);
\end{lstlisting}

\section{Collate}
\begin{Verbatim}
value = collate( map or list-expression, string-expression )
\end{Verbatim}

The collate function works in a similar way to the sort function except that the second
parameter specifies a \emph{locale} that should be used for the sorting collation function.
The locale is specified using Java's Locale class, as an example the locale for the UK is
\Verb+en_GB+.

\begin{lstlisting}[caption={Collate example}]
x = ['a','c','d','b'];
y = collate(x, 'en_GB');
assert(y == ['a','b','c','d']);
\end{lstlisting}

\section{GetLine}
\begin{Verbatim}
line = getline( )
\end{Verbatim}

The getline function reads the next line from the stdin io stream, assuming that the \Reflex container
has an input handler. In most environments this is not the case, only the environment setup by \Verb+ReflexRunner+ has an
input handler.

\section{GetCh}
\begin{Verbatim}
ch = getch( )
\end{Verbatim}

The getch function reads the next character from the stdin io stream, assuming that the \Reflex container
has an input handler. In most environments this is not the case, only the environment setup by \Verb+ReflexRunner+ has an
input handler.

\section{Capabilities}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

The capabilities function returns a map containing the status of each of the following capabilities present in the \Reflex container
on which this script is running.

\begin{table}[h!]
\centering
\small
\begin{tabular} { | c | p{7cm} | }
\hline
Key     &  Meaning \\
\hline
DEBUG & Is there a debugger attached \\
CACHE & Does the container have a cache \\
DATA & Can the container retrieve data from \Rapture \\
IO & Can the container perform file io? \\
OUTPUT & Can the container write out information using print? \\
SCRIPT & Can the container run other scripts? \\
SUSPEND & Can the container suspend scripts for later resumption? \\
\hline
\end{tabular}
\label{tab:Capabilities}
\caption{Capabilities of a Reflex Container}
\end{table}

The return value is a map that contains two keys - "ON" and "OFF" with the values associated
with that key being a list of the capabilties defined above. E.g.

\begin{lstlisting}[caption={Capabilities example}, language=reflex]
x = capabilities();
println(x);
// prints out {ON=[SCRIPT, PORT, IO, CACHE, OUTPUT, DATA, OFF=[DEBUG, SUSPEND]}
\end{lstlisting}

\section{HasCapability}
\begin{Verbatim}
hascapability(string-expression)
\end{Verbatim}

The hascapability function returns true or false depending on whether the \Reflex container
has the given capability. The list of Table~\vref{tab:Capabilities} shows the possible choices for
capabilities to be tested.

\begin{lstlisting}[caption={HasCapability example}, language=reflex]
x = hascapability('DEBUG');
println("Debug is ${x}");
\end{lstlisting}

\section{Replace}
\begin{Verbatim}
string-or-list = replace( string-or-list-expression,
      expression, expression )
\end{Verbatim}

The replace function is used to replace elements of a list or characters in a string. The
first parameter is the value to be worked on. It can be a list or a string. The second parameter is
an expression that is used to match either parts of the value string or elements in the value list. The third
parameter is what those elements should be replaced with. The return value has the same type
as the first parameter.

\begin{lstlisting}[capture={replace example}]
hello = 'Goodbye, world!';
goodbye = replace(hello, 'Goodbye', 'Hello');
// goodbye is now 'Hello, world!'

lval = [1, 2, 3, 4];
nval = replace(lval, 1, 5);
// nval is now [5,2,3,4]
\end{lstlisting}

\section{Transpose}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{B64Compress}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{B64Decompress}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{Evals}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{MkDir}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{Remove}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{Join}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{Copy}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{Close}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{Timer}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{Vars}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{Format}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{PutCache}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{GetCache}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{UrlEncode}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{UrlDecode}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{Matches}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}

\section{Rand}
\begin{Verbatim}
cap = capabilities( )
\end{Verbatim}
